
  // addRowWithValues({ table:document.getElementById('full_plot_tb'), values:{ item:"new_item", type:"auto", value:"new_value", DELETE:"del"} });
function addRowWithValues({ table, values }){
  // var table = document.getElementById('input_occ_a_tb'); var layer = 'H'; var species = 'new_species';
  // var table = document.getElementById('full_plot_tb'); var key = "item"; value = "new_val";
  addRow(table);
  var c_names = getColNames(table);
  var keys = Object.keys(values);
  var row_no   = table.rows.length - 1;
  for(let key of keys){
    var col_no = c_names.indexOf(key);
    var td = table.rows[row_no].cells[col_no];
    var value = (values[key] === void 0) ? '' : values[key];
  // console.log(td);
  // console.log(values);
  // console.log(key);
    if(td.firstChild === null){
      td.innerHTML = value;
    }else{
      if(td.firstChild.value === void 0){
        td.innerHTML = value;
      }else{
        td.firstChild.value = value;
      }
    }
  }
}

// Helper to call addRow() multiple times
//    @param obj  A input element.
//                  Normally use "this". 
//    In BISS, addRows() is generated by createAddRowButton() as below. 
//      createNrowInput() is necessary as well.
//      
//      // Down span
//      var dn = crEl({ el:'span', ats:{id: "dn_" + ns} });
//      dn.appendChild( createNrowInput() );
//      dn.appendChild( createAddRowButton() );
//      // Main
//      var main   = crEl({ el:'span', ats:{id: "main_"   + ns} })
//      main.appendChild(up);
//      main.appendChild(table);
//      main.appendChild(dn);
//      main.appendChild( crEl({ el: 'hr' }) );
function addRows(obj){
  // console.log(obj);
  //   var table = obj.parentNode.parentNode.querySelectorAll("table")[0];
  var n_row = obj.previousElementSibling.value;
  var table = searchParentTable(obj);
  for(let i = 0; i < n_row; i++){ addRow(table); }
}

// Copy buttom row and paste it as new rows
//    Column date  getNow() will be applied.
//    Column fixed and <select> <option> will be used the same selection.
//    Column "checkbox" and "text" will be made as unchecked and blank one.
//    
function addRow(table){
  // console.log(table);
  const col_names = getColNames(table);
  const n_col = col_names.length;
  const n_row = table.rows.length;
  var last_row = table.rows[n_row - 1];  // to get selectedIndex
  var next_row = table.rows[n_row - 1].cloneNode(true);
  for(let Ci = 0; Ci < n_col; Ci++){
    switch(col_names[Ci]){
      case "DATE":  // update "DATE"
        next_row.children[Ci].innerHTML = getNow();
        break;
      case "LOC_LAT":  // update GPS data
        next_row.children[Ci].innerHTML = getLat();
        break;
      case "LOC_LON":
        next_row.children[Ci].innerHTML = getLon();
        break;
      case "LOC_ACC":
        next_row.children[Ci].innerHTML = getAcc();
        break;
      case "UPDATE_TIME_GPS": // do nothing
      case "DELETE":          // do nothing
        break;
      case "NO":             // no = max(no) + 1
        var nos = getColData(table, col_names[Ci]);
        next_row.children[Ci].innerHTML = Math.max.apply(Math, string2Numeric(nos)) + 1;
        break;
      case "SameAs":        // clear
        next_row.children[Ci].innerHTML = "";
        break;
      default:
        if(next_row.children[Ci].firstChild.value === void 0){  
          // void 0 means undifined -> fixed text: do nothing
          break;
        } else {
          switch(next_row.children[Ci].firstChild.getAttribute("type")){
            case "text":    // clear input text
            case "number":  // clear input text
              next_row.children[Ci].firstChild.value = "";
              break;
            case null:      // select from list
              selected_opt = last_row.children[Ci].firstChild.selectedIndex;
              next_row.children[Ci].firstChild.selectedIndex = selected_opt;
              break;
            case "checkbox": // do nothing
  // if want 'Identified' checked and others no checked -> activate the codes below
  //               if(col_names[Ci] === 'Identified'){ next_row.children[Ci].firstChild.checked = true; 
  //               }else{                              next_row.children[Ci].firstChild.checked = false; }
              break;
          }
        }
        break;
    }
  }
  table.appendChild(next_row);
}
