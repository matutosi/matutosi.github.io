[["index.html", "Rにる作業の効率化・自動化 -パッケージ活用術- はじめに 0.1 対象とする読者 0.2 特徴 0.3 読み方", " Rにる作業の効率化・自動化 -パッケージ活用術- Toshikazu Masumura 2023-05-26 はじめに 誰でもそうだろうが，面倒くさい仕事はしたくない． というか，したくないことが面倒くさいのだろう． ニワトリとタマゴの議論は別として，できることなら面倒な作業はしたくない． でも，しなければならないのなら自動化したい． もちろんすべての仕事を自動化できるわけでもないし，作業内容によっては文章執筆のように自動化すべきでないこともある． 作業の自動化には，プログラミング言語を使うことが多い． 自動化でよく使われる言語にPythonがある． Pythonは比較的習得しやすい言語らしく，多くの人が使っている． 自分自身も多少はPythonを使えるものの，それよりもRの方が慣れている． できることなら(ほぼ)全ての作業をRでやってしまいたい． そんなわけで，この文章ではRを使った作業の自動化や効率化手法を紹介する． 基本的に独学でここまで来たので，我流や汚いコードが多くあると思われるがご容赦頂きたい． また，改善案をご教示いただければありがたい． matutosi@gmail.com 0.1 対象とする読者 この文書は，以下の人を読者として想定している． 1 Rを使って操作を自動化したい 2 プログラミングの基礎知識を持っている 3 エラーが出た時に自分でネットで調べて解決できる 4 自己責任でコードを実行できる 1つ目は言うまでもないが，Rを使って自動化をしたい人を対象としている． Pythonに慣れている人は，Pythonを使ったほうが早いかもしれない． あまり無いかもしれないが，Pythonでは実行できずRだけで実行できるものがあるかもしれない． その場合は，その部分だけR本体で実行するとか，rpy2ライブラリを使えば良いかもしれない． 2つ目のRの基礎知識があれば良いが，既に仕事や研究などでRを使っていれば問題ないだろう． この文書の多くのコードをほぼそのまま利用できるはずだ． Rを使ったことはなくても，他のプログラミング言語を使っていれば大丈夫である． Rやパッケージのインストールについての説明をもとにRを導入して，magrittrやstringrなどの部分を読めばある程度の理解ができるだろう． ただし，十分ではないと思われるので，しっかり勉強しようという人は，別の書籍を1冊読むことをおすすめする． Rではじめるデータサイエンス 改訂2版 RユーザのためのRStudio[実践]入門 RStudioではじめるRプログラミング入門 3つ目のエラーについてだが，OSの違いやその他の環境の違いによって，この文書のコードを実行したときにエラーが発生する可能性がある． その場合，自分のまわりにR上級者がいれば，質問できるだろう． しかし，そうでないときには，自分でネットで検索して解決しなければならない． そのときには，実行したコードとエラーの内容をもとに検索して解決して欲しい． できれば，日本語よりも英語で検索するのが良い． 圧倒的に情報量が違うからだ． エラーが発生して，検索しても解決しなければ質問を送って頂いても，もちろん構わない． ただし，Windows以外のOSはほとんど使ったことがないため対処できない可能性が高いことや， Windowsであっても全てに対処できるわけではないことはご了承頂きたい． 4つ目の自己責任については，プログラムの基本中の基本である． 特に作業を自動化するということは，危険な場合がある． この文書や改良したコードを実行して何らかのデータが消失したり，損害を与えたりする可能性がある． そのためコードの実行には注意をするとともに，自己責任で実行してほしい． ファイルの上書き保存や削除の際には，細心の注意が必要だろう． ファイルの保存のときには上書きするのではなく，作業ディレクトリに一旦コピーしてから作業すると良いだろう． 削除のときは，ディレクトリ全体ではなく個別のファイル名を指定すると，「すべて消えてしまった!」という間違いを回避できる可能性が高い． 0.2 特徴 この文書の特徴は，以下の2つがある． Rを使った自動化の解説である コードをほぼそのまま実行できる(GitHub) 自動化についてR(Pythonではなく)を使った解説に焦点を当てていることである． Pythonを使った自動化については多くの書籍やネット上にも多くの文書がある． Python自体がプログラミング言語で最も使われているものの一つで，自動化のためのライブラリも充実しているからだ． RはPythonと比べられることがあるものの，どちらかといえば統計解析に特化した言語として捉えられている． 実際にそうではあるが，Rにも結構多くの機能があり，自動化のためのパッケージも充実している． Pythonは勉強したい言語や使っている言語の上位に位置する． 一方，Rは使いたくない言語としてあげられることがある． Rは他の言語と比べるとちょっと独特なところがあるからだ． それでも使ったことがない人は，一度使ってみてほしい． 独特なところが結構クセになる． この文書のコードはコピペすれば，ほぼそのまま実行できる． GitHubにもコードがあるので，使ってほしい． 読者の環境に合わせて，入力するべきとこももちろんある． その部分は，your_directoryなどのように表記している． ただし，自動化の方法は1つだけではない． 1つのことをするにしても，system()でのコマンドの実行やパッケージの関数の利用などのように複数の方法がある． プログラムをする場合は，後で見直して自分で修正できるようにすることが重要だ． まずは，この文書のコードをコピペして使い，分かりにくい部分は自分なりの書き方に変えてほしい． その上でさらに改善を重ね，コードを組み合わせると独自の自動化手法ができる． 0.3 読み方 ???章のRやパッケージのインストールについてを除いて，基本的には各章の内容は独立しているので，読者の興味に合わせて好きな部分を読めば良いだろう． 各章では，パッケージごとに基本的な関数の説明や自動化のための活用方法を紹介している． ただし，magirittr，stringr，fsパッケージは他の章でもよく使っているので，まずはここから読むと理解が早いと思われる． また，これら以外にも他の章で解説するパッケージを利用していることがあるので，必要に応じて関連部分を読んでほしい． "],["R.html", "Chap. 1 Rとは 1.1 特徴 1.2 1点突破", " Chap. 1 Rとは この文章では，好みとしてRを使っている． Rは，統計解析環境であるとともに，プログラミング言語である． プログラミング言語としては，やや特殊な文法をもっている． そのため，他の言語よりも好き嫌いが激しいと思われる． どうしてもRを使うのが嫌であれば，Pythonでの自動化について書いた書籍が多くあるので，それらを参考にして欲しい． 1.1 特徴 プログラミング言語としてのRが文法的に特殊な点では，代入での&lt;-使用とパイプ(|&gt;(R 4.1以降)や%&gt;%)の多用が挙げられる． 他の多くのプログラミング言語では，代入には=を使用する． Rでも=を使えるが，&lt;-を好んで使う人が多いと思われる． 少なくとも私はそうしている． 理由を問われても特には思いつかないが，慣れていることや，コードを見た時にすぐにRだとわかるぐらいだろうか． 実用的には，=を入力するよりも手間がかかるし面倒なはずであるが，すでに手が慣れてしまっている． パイプを最初に見たときには違和感を覚えたが，使い始めるとクセになる． クセになるだけではなく，同じ変数名を何度も使ったり，中間の変数名を考えなくて良い点で優れている． 第1引数を省略できるため，入力の手間が少ない． パイプだけの恩恵でなく，tidyverseの利用も大きいが，コードが簡潔になって，コードの使い回しがし易い． パイプにはこのような多くの利点がある． 他にも::がやたらと出てくることや，実行速度が遅いなどの欠点もそれなりにある． ::はlibrary()でパッケージを呼び出せば，使わなくても良いことが多い． ただし，この文章で関数がどのパッケージのものかを示すために，不要な場合でも明示している場合が多い． 実行速度が遅いのは，Rだけでなくインタプリタの宿命である． Pythonもインタプリタでありそれ自体は実行速度は遅い． しかし，RでもPythonでも内部的ではCやC++を使っており，RやPython自体で過度にループを使ったりしなければ実用的にはほとんど問題ない． そもそも完璧なプログラミング言語などそ存在せず，それぞれに利点・欠点がある． それぞれの得意な分野でうまく使うことが重要である． とはいいながら，多くのプログラミング言語を習得するのは困難である． ちょっとだけでもこれまでにかじったことのある言語としては， FORTRAN，Perl，Ruby，C，C++，VBA，Java，Python，JavaScript，Rなどがある． それぞれなんとなく読むことはできるが，実際によく使うのはRだけである． JavaScriptはその次に使っているが，頻度は非常に低い． Pythonは勉強中である． Rにはヘルプ・ドキュメントがしっかりしているというのも非常に良い． ヘルプは，「?関数名」としてRから直接呼び出すことがでる． 関数の引数，返り値，使用例などが詳しく解説されていることが多い． ユーザーとしてはいちいちネットや書籍で調べなくても良いのが心強い． パッケージの開発者としては，既存のパッケージのドキュメントがしっかりしている． そのため，それに合わせるべく，しっかりとしたドキュメントを書かなければならないという心理的な圧力がある． ただ，ドキュメントをしっかり作っておかないと，開発者も関数の使い方を忘れてしまうことになりかねないため，結局は「他人のためならず」である． 1.2 1点突破 プログラミング言語にはそれぞれ得意分野があることは確かだが，垣根を超えて使うことができる． 例えば，RからPythonを使うパッケージとしてreticulateがあり，PythonからRを使うライブラリとしてrpy2がある． つまり，1つのプログラミング言語でしか実行できないものはほとんどなく，使いたい言語を使って勉強したい言語を勉強すれば良い． 汎用的なプログラミング言語では，Python，C，C++，Javaが，Web関連ではJavaScriptが広く使われている． これらの言語に関連した多くのパッケージが，Rの総本山であるCRANに登録されている． そのため，Rを通してこれらの言語やそのパッケージが利用可能である． 多くの言語を習得するのも良いが，習得にはかなりの時間が必要である． いっそのこと1つの言語をある程度極めて，そこから使うのは良い方法と言えるだろう． つまり一点突破の手法である． そこで，Rのパッケージを使って，各種操作をすることを目的にこの文章を執筆した(している)． もちろんだが，エラーが出たときの対処やより良い利用のためには，それぞれの言語のことを少しは知っておいた方が良い． 場合によっては，R以外の言語でコードを書く方が良い場合もある． 私自身の例としては，編集距離を計算するコードをCで書いたことがある． 編集距離は，植物の学名や和名の間違い候補を提案するための関数を作成するために必要であったが，Rでの実装では実行速度に問題があった． そのため，部分的にCで書いてそれをパッケージRcppを利用して自作のパッケージに組み込んだ． 正直なところはCで書いたというよりも，参考になるコードをネットから探して，多少アレンジしただけである． このような利用は実際のRのパッケージでも多く採用されており，R本体や各種パッケージの多くの関数はCやC++で実装されている． 結局のところ，表面的にはRを使っていても，他の言語のお世話になっていることは多い． Rだけでもかなりのことはできるし，他の言語であっても結局は同じようなことが言える． Rに限らず自分の得意とする言語を深く勉強するとともに，他の言語も少し知っておくのが良いだろう． "],["install.html", "Chap. 2 Rのインストール 2.1 ダウンロード 2.2 インストーラの起動 2.3 インストール完了", " Chap. 2 Rのインストール Rのインストール方法は，ネットでも多く掲載されている． ここでは，オプションの個人的な好みを強調しつつ説明する． 2.1 ダウンロード OSに合わせたインストーラをダウンロードする． Windowsの場合は，「Download R-4.x.x for Windows」(xはバージョンで異なる)である． https://cran.r-project.org/bin/windows/base/ 2.2 インストーラの起動 ダウンロードしたファイルをクリック． 「…許可しますか?」に対して，「はい」を選択する． インストール中に使用する言語 何でも大丈夫なので，好きなものを選ぶ． インストールの確認 「次へ」をクリック． インストール先のフォルダ そのままでOKである．好みがあれば変更する． インストールするもの とりあえず，すべてチェックしておくくと良い． Message translationは，Rからのメッセージを日本語に翻訳するかどうか． チェックを入れないと，英語表示になる． 結論としては，とりあえずチェックを入れておき，必要に応じて英語で表示させるという方法が良いかもしれない． チェックを入れておくと，エラーメッセージは日本語で表示できる． 「そら日本語のほうが良いやん」と思うかもしれない． よくわからないエラーメッセージが英語で表示されたら，わけがわからないからだ． ただ，プログラミングの世界では，英語でのエラーメッセージのほうが便利なことが結構ある． それは，エラーメッセージをそのままネットで検索するときである． 日本語でのエラーメッセージではネット上の情報が限られる． 一方，英語でのエラーメッセージで検索すると，原因や対処方法をかなりの確率で知ることができる． インストール後の設定変更は以下を参考にして欲しい． # https://cell-innovation.nig.ac.jp/SurfWiki/R_errormes_lang.html Sys.getenv(&quot;LANGUAGE&quot;) # 設定の確認 # 設定の変更方法 Sys.setenv(LANGUAGE=&quot;en&quot;) # 英語に変更 Sys.setenv(LANGUAGE=&quot;jp&quot;) # 日本語に変更 オプションの選択 とりあえず「Yes」を選択する． 以下のオプションを選択するかどうか． ウィンドウの表示方法(MDI / SDI)の選択 個人的な好みはSDIだが，好みの問題なので正直どちらでも大丈夫である．． MDI(左)は大きな1つのWindowの中に，コンソール(プログラムの入力部分)，グラフ，ヘルプなどが表示される． SDI(右)はコンソール，グラフ，ヘルプが別々のWindowとして表示される． どちらかといえば，自由度が高い． ヘルプの表示方法(Plain text / HTML help)の選択 個人的な好みはPlain textだが，好みの問題で正直どちらでも構わない． Plain textはテキストファイルで表示されるシンプルなつくりである． HTML helpはヘルプがブラウザ(GoogleChrome等)で表示される． 関連する関数などへのリンクが表示されるので，それらを参照するときは便利である． その後の設定 その他は，既定値(そのまま)でOKである． 2.3 インストール完了 インストールが完了すると，アイコンがデスクトップに表示される． アイコンをクリックすると，Rが起動する． "],["package.html", "Chap. 3 パッケージのインストール 3.1 CRANから 3.2 アーカイブされたパッケージ 3.3 CRANからPackage一覧を取得する 3.4 GitHubから", " Chap. 3 パッケージのインストール R単体でも多くの機能があるものの，実際には各種パッケージを利用することが多い． パッケージのインストールには，Rで簡単なコマンドを実行するだけである． 多くのパッケージが，Rの総本山のCRANに登録されている． https://cran.r-project.org/ CRANに登録するには，それなりに厳しいチェックがある． ただし，私でも登録できていることが証明しているが，CRANに登録されたからといってバグが無いわけではない． そのためR本体もそうだが，Rのパッケージ利用はあくまで自己責任である． CRANに登録されたパッケージの開発バージョンは，GitHubで公開されていることが多い． また，CRANには登録されずGitHubのみで公開されているパッケージも存在する． 3.1 CRANから CRANではR本体だけでなく，各種パッケージが公開されている． なお，パッケージの名前は分かっているが，内容がよくわからない場合は，PackageName cranで検索するとCRANのページがひっかかることが多い． https://cran.r-project.org/web/packages/available_packages_by_name.html CRANに登録されたパッケージで名前がわかっていたら，以下のようにすればインストールできる． # ミラーサイト(ダウンロード元)の設定 options(repos = &quot;https://cran.ism.ac.jp/&quot;) # 1つの場合 install.packages(&quot;tidyverse&quot;) # 複数の場合 pkg &lt;- c(&quot;xlsx&quot;, &quot;magrittr&quot;, &quot;devtools&quot;) install.packages(pkg) 実行すると，ファイルをダウンロードし，成功(あるいは失敗)したことが表示される． 3.2 アーカイブされたパッケージ 過去にCRANに登録されたが，その後何らかの理由でCRANからは削除されたパッケージがある． その場合でも，アーカイブ化されたものがCRANには保存されているため，そこからインストールできる． また，パッケージの古いバージョンをインストールする場合にも同じ手法が使える． zip &lt;- &quot;http://cran.nexr.com/bin/windows/contrib/3.5/rMouse_0.1.zip&quot; setwd(&quot;d:/&quot;) devtools::install_local(&quot;d:/rMouse_0.1.zip&quot;) 3.3 CRANからPackage一覧を取得する CRANに登録されているパッケージは，2023年5月現在で2万近くになっている． たくさんあることは嬉しい反面，目的とするパッケージを検索するのは困難である． パッケージ一覧のページで検索しても良いが，ブラウザでは正規表現が使えないことが多い． そこで，パッケージの一覧を取得して，自分のパソコンの中に一覧を保存して，その後でRやエディタの正規表現を用いて検索できるようにする． library(tidyverse) library(magrittr) library(rvest) # wd &lt;- &quot;your_directory&quot; # wd &lt;- &quot;D:/matu/work/tmp&quot; # setwd(wd) url &lt;- &quot;https://cran.r-project.org/web/packages/available_packages_by_name.html&quot; html &lt;- rvest::read_html(url) # rvestは第???章を参照 pkgs &lt;- html %&gt;% rvest::html_table(header = TRUE) %&gt;% `[[`(1) %&gt;% # .[[1]]と同じ magrittr::set_colnames(c(&quot;pkg&quot;, &quot;description&quot;)) %&gt;% # magrittrは第???章を参照 stats::na.omit() %&gt;% dplyr::mutate( # dplyrは第???章を参照，stringrは第???章を参照 description = stringr::str_replace_all(description, &quot;\\n&quot;, &quot; &quot;)) readr::write_tsv(pkgs, &quot;pkgs.txt&quot;) # readrは第???章を参照 dplyr::filter(pkgs, stringr::str_detect(description, &quot;Image|image&quot;)) 詳しい説明は省略するが，以下を実行するとpkgs.txtというテキストファイルが作業ディレクトリに保存される． また，「Image」か「image」がdescriptionに含まれるものが出力される． すべてを画面に出力したい場合は，最後にコメントアウトした3行を実行する． 検索結果をwrite_tsv()でテキストファイルとして保存するのも良いだろう． パッケージとその説明の一覧を分析する方法は，tidyverseの章を参考にしてほしい． 3.4 GitHubから たいていはCRANに登録されているが，GitHubにしかないパッケージのときは以下のようにする． install.packages(&quot;devtools&quot;) devtools::install_github(&quot;matutosi/ecan&quot;) "],["assoc.html", "Chap. 4 スクリプトの関連付け 4.1 Windows 4.2 MacとLinux", " Chap. 4 スクリプトの関連付け 4.1 Windows Rのプログラムのファイルは拡張子「script.R」のように「R」という拡張子を付けて保存することが多い． 拡張子「docx」をワードで，「xlsx」をエクセルで開くのと同様に，私は「R」をテキストエディタで開くするように設定している． その後，開いたファイルをRのコンソールに貼り付けて，プログラムを実行する． このような使い方でもちろん良いのだが，コードの内容を変更しないのであれば，いちいちRを起動してコードを貼り付けるのは面倒臭い． ファイルをクリックするだけで，プログラムが実行されれば便利である． プログラムのファイルをRに関連付けることで，これが実現できる． プログラムのファイル名を「R」から「scr」に変更する(「scr」は大文字小文字は関係なく，「Rsc」や「RSC」などでもOK)． 拡張子が表示されていない場合は，エクスプローラの表示のオプションで，「登録されている拡張子は表示しない」のチェックを外して(チェックしないで)，「OK」を選択してから，名前を変更する． ファイルを右クリックして，「プロパティ」を選択する． 「全般」タブのやや上にあるプログラムの「変更」を選択する． 「PCでアプリを選択する」をクリックする． ファイル選択画面で，Rをインストールしたフォルダまで辿っていき(「c:\\Program files\\R\\R-4.2.3\\bin\\x64」など)，「Rscript.exe」を選択する． 「.rscファイルの既定のアプリを選択する」で「R for windows front-end」が表示されるので，「既定値を設定する」を選択する． 全般タブのプログラムが「R for windows front-end」になっていることを確認して．「OK」を選択する． ファイルのアイコンがRのアイコンになっていたらOKである． ダブルクリックすると，ファイルの内容が実行される(はず)． 4.2 MacとLinux MacでRのスクリプトファイルを簡単に実行するには以下の方法がある． plot.R などの名前でRのコードを保存 シェルスクリプトのファイル(例：plot.sh)を用意 plot.sh をクリックして実行 簡単な例として散布図をpdfに保存するコードを取り上げる． 次のコードをRで実行すると，乱数(x軸：一様分布，y軸：正規分布)に基づく散布図がpdfとして保存される． # コード例 # ユーザディレクトリにtest.pdfというファイルを生成 pdf(&quot;~/test.pdf&quot;) plot(1, 1) dev.off() このコードをユーザ・ディレクトリ(~/)に保存する． ファイル名は何でも良いが，ここではplot.Rとする． 次に，plot.Rを実行するためのシェルスクリプトを作成する． このファイル名も何でも良いが，ここではplot.shとする． もちろん，Rと別のファイル名でも構わない． plot.shの中身は次のようにする． #! /bin/bash /usr/local/bin/Rscript ~/plot.R #!ではじまる1行目はシバンとよばれるもので，ある種のおまじないである． /bin/bashというシェルで実行せよという意味である． 2行目の/usr/local/bin/RscriptはRscriptというプログラムを実行する部分である． Rをインストールすると，/usr/local/bin/か/usr/bin/のどちらかにRscriptというプログラムが保存されている． どちらに保存されているかは，そのときの設定によると思われるが，読者の環境に合わせる． ~/plot.Rの部分は実行するRのコードのファイルを指定する． 他のファイルを実行する場合は，この部分を変更する． これで準備が完了したので，plot.shをクリックすればplot.RがRscriptで実行され，plot.pdfを生成するはずである． うまくいかなければ，plot.shに実行権限が設定されていないことが考えられる． Terminalからplot.shのあるディレクトリで以下のように実行すれば，実行権限を設定する． chmod +x plot.sh Linuxでも同様の方法で実行できるようになるはずである． "],["magrittr.html", "Chap. 5 magrittrでコードを簡潔に 5.1 準備 5.2 magrittrとtidyverse 5.3 %&gt;%でコードを簡潔に 5.4 パイプの仲間 5.5 パイプ以外の関数 5.6 おまけ：magrittrの不思議な関数たち", " Chap. 5 magrittrでコードを簡潔に パッケージmagrittrはちょっと変わったパッケージである． そもそも名前が変わっていて何と読んで良いのか分からない． 公式ページには「magrittr (to be pronounced with a sophisticated french accent) 」と書かれている． フランス語は，大学の第2外国語で習ったが，すでに記憶の彼方に沈んでしまっている． 主な関数がパイプ(%&gt;%)である点も変わっている． このように，ちょっと変わったパーッケージではあるものの，Rを使う際には欠かせないパッケージといっても過言ではない． Rのバージョン4.1以降では，base機能のパイプとして|&gt;が使えるようになったが，第1引数(_)とその名前を明示しないといけないなど若干使いにくい． そこでここでは，コードを簡潔に書くためのmagrittrのパイプ(%&gt;%)と関連した関数を紹介する． 5.1 準備 例によって，インストールとパッケージの呼び出しをしておく． install.packages(&quot;magrittr&quot;) library(tidyverse) library(magrittr) 5.2 magrittrとtidyverse tidyverseは，Rでのデータ解析には欠かせないものになっている． Rの起動時にtidyverseを読み込む人は多いだろう． tidyverseを読み込むと，その中のパッケージ(forcats，tibble，stringr，dplyr，tidyr，purrr)がインポートした%&gt;%を使うことができる． そのため，私は%&gt;%がtidyverseの独自のものだと勘違いをしていた． %&gt;%はもとはパッケージmagrittrの関数である． ただし，tidyverseと%&gt;%の相性は非常によい． tidyverseの関数では，第1引数のオブジェクトがdplyrではデータフレーム，stringrでは文字列などのように，それぞれのパッケージで引数とするオブジェクトが統一されている． そのため，簡潔にコードを書くことができる． なお，パイプの手入力は手間がかかるので，ショートカットを利用する． RStudioでは，Ctrl + Shift + Mである． テキストエディタを使っているときはマクロやスクリプトを組んでショートカットを設定することをお勧めする． %&gt;%は，慣れるまでは何が便利なのか分からないが，慣れると欠かせなくなる． さらに使っていると，癖なってしまって無駄にパイプを繋ぐこともある． 長過ぎるパイプは良くないのは当然であるものの，適度に使うとRでのプログラミングは非常に楽になる． 5.3 %&gt;%でコードを簡潔に 最近のRでは，パイプ(%&gt;%)を多用したコードをよく目にする． はじめてみると，面食らって思考停止に陥ってしまうかも知れない． しかし，恐れることはない． 以下では簡単な例を使って説明する． a &lt;- a %&gt;% fun() # あるとき：慣れていないと変な感じ a &lt;- fun(a) # ないとき：こっちのほうが分かりやすい ある時とない時と比べると，ある時の方がコードが長くなっていて，何が便利なのかわからないだろう． 著者も正直なところ，少し見たときには便利さが全くわからなかった． # ないとき：「a &lt;- 」が何度も必要 a &lt;- fun1(a) a &lt;- fun2(a) a &lt;- fun3(a) # 力技!：括弧が見づらい a &lt;- fun3(fun2(fun1(a))) # あるとき a &lt;- a %&gt;% # aに(以下の結果を)代入 fun1() %&gt;% # fun1を実行 fun2() %&gt;% # fun2を実行 fun3() %&gt;% # fun3を実行 パイプを使うと，左側のオブジェクトを右側の関数の第1引数として使うため，引数が1つだけの場合は引数を書く必要がなくなる． このようにオブジェクトaに対して， fun1，fun2，fun3と順に関数を適用するということは，しばしば出てくる． 特に，dplyrでselect()，filter()，group_by()，summarise()などを使う時はそうである． その時，代入先のオブジェクト名を1回ずつ新たに考えるのは，非常に面倒である． どこまでを同じ変数名として，どこで変えるかなど考えるのは手間だ． キーボードでの打ち込みが多いほど，オブジェクト名の重複や入力間違いが発生する可能性が高くなり，バグの温床である． これを避ける方法は入れ子状に書くことであるが，括弧の対応がよくわからず頭が混乱する． 正直なところ，著者は時々このようなコードを書くことがある． しかし，他人から見たらこんな馬鹿げて見にくいコードは無い． パイプを使うと，これらの問題が解決する． また，見た目にもわかりやすくコードの再利用もしやすい利点もある． 見た目では，1つの作業が1行にあるため，可読性が高く人間の思考回路にも近い． 再利用するときに，処理対象のオブジェクトを引数として明記しなくても良いため，前後の文脈に左右されずに必要な部分のコードだけを複写・貼付できる． 慣れるには，ほんの少しの時間がかかるかもしれないが，ぜひとも活用してほしい． 5.4 パイプの仲間 %&lt;&gt;% %T&gt;%(Tパイプというらしい) %$% これらの関数は，tidyverseには含まれていないため，使用するにはmagrittrを読み込む必要がある． %&gt;%と似た機能を持つ． 5.4.1 %&lt;&gt;%でオブジェクトを代入 %&lt;&gt;%は，パイプを使って処理した内容を，最初のオブジェクトに再度代入するときに使う． ほんの少しだけ，コードを短くできる． head(mpg) # 燃費データ ## # A tibble: 6 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## 4 audi a4 2 2008 4 auto(av) f 21 30 p compa… ## 5 audi a4 2.8 1999 6 auto(l5) f 16 26 p compa… ## 6 audi a4 2.8 1999 6 manual(m5) f 18 26 p compa… tmp &lt;- mpg tmp &lt;- tmp %&gt;% dplyr::filter(year==1999) %&gt;% tidyr::separate(trans, into=c(&quot;trans1&quot;, &quot;trans2&quot;, NA)) tmp &lt;- mpg tmp %&lt;&gt;% dplyr::filter(year==1999) %&gt;% tidyr::separate(trans, into=c(&quot;trans1&quot;, &quot;trans2&quot;, NA)) 注意点としては，試行錯誤でコードを書いている途中は，あまり使わないほうが良いだろう． もとのオブジェクトが置き換わるので，処理結果が求めるものでないときに，もとに戻れなくなってしまうためだ． コードを短くできるのは1行で，可読性が特に高くなるというわけでもない． 便利なことは便利で，私も一時期はよく使用していた． しかし，上記の理由もあって，最近はほとんど使用していない． 5.4.2 %T&gt;%でコードを分岐 処理途中に分岐をして別の処理をさせたいときに使う． 例えば，ちょっとだけ処理して，変数に保存するときに使う． imapと組み合わせて，保存する画像のファイル名を設定する時に使うと便利である． %T&gt;%は便利ではあるが，以下の点で注意が必要である． 分岐途中の結果をオブジェクトに代入するときには，&lt;-ではなく，&lt;&lt;-を使う 明示的に.を使う 複数処理があれば，{と}で囲う 処理終了後に%&gt;%が必要 %T&gt;%を使うとコードの途中に，ちょっとだけ枝分かれしたコードを挿入できる． 有用な機能ではあるが，トリッキーなコードになる可能性があるため，使いすぎには気をつけたい． 以下の例は，あまり実用的なものではないが，簡単な例として示す． iris %&gt;% tibble::tibble() %&gt;% split(.$Species) %&gt;% # Speciesで分割 purrr::map(print, n = 3) %T&gt;% # それぞれ3行だけ表示 { sp_path &lt;&lt;- paste0(names(.), &quot;.txt&quot;) # ファイル名：種名.txt } %&gt;% purrr::map(dplyr::select_if, is.numeric) %&gt;% # 数値だけを選択 purrr::map(dplyr::summarise_all, mean) %&gt;% # 平均を算出 purrr::map2(.x = ., .y = sp_path, readr::write_csv) # 種ごとにcsvを保存 Tパイプは，Tの文字の形が意味をなしており，左から来たデータを分岐させて右側と下側に流す役割をする． 上の例では，分岐した途中でファイル名sp_pathを生成するために，(わざと)分岐を入れている． このコードで本来{}は不要だが，入れておくとTパイプを使っている部分がわかりやすい． ファイル名を生成したあと(}の後ろ)には，上から流れてきたものがそのままpurrr::map()の第1引数として使われる． select_if()とdplyr::summarise_all()をしてから，最終的にファイルとして出力する． map2()はmap()の引数を2つとるバージョンであり，第1引数に上から来たデータフレームを，第2引数にファイル名を使っている． なお，最後のmap2()をpurrr::walk2とすると種ごとの平均値は画面には出力されず，ファイルへの出力だけになる． さらに余談だが，上で「(わざと)」と書いたのは，Tパイプを使わずに，最後のところをmap2(.x = ., .y = paste0(names(.), \".txt\"), readr::write_csv)とすれば同じ結果が得られるためである． iris %&gt;% tibble::tibble() %&gt;% split(.$Species) %&gt;% purrr::map(dplyr::select_if, is.numeric) %&gt;% purrr::map(dplyr::summarise_all, mean) %&gt;% map2(.x = ., .y = paste0(names(.), &quot;.txt&quot;), readr::write_csv) 5.4.3 %$%で$のショートカット %$%は，%&gt;%と.$の組み合わせのショートカットである． mpg %&gt;% .$manufacturer %&gt;% head() ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; mpg %$% manufacturer %&gt;% head() ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; パッケージ開発ではパイプを使った場合の.が推奨されていない． パッケージ開発時に欠かせないチェック(R CMD check)ではpossible problemとしてWarningが出力される． そのため，そのままではCRANでは受け付けてもらえない． Githubでパッケージを公開するならそれでも問題はないが，Checkで毎回Warningが出力されるのは，心理的に嬉しくない． そこで，DESCRIPTIONで次のように%$%をインポートしておくと，.$を使わなくても良い． importFrom(magrittr,&quot;%$%&quot;) なお余談ではあるが，この場合は$の代わりに[[と]]を使っても同じ結果が得られる． [と]ではデータフレームの1列をそのまま取り出すので，結果が異なる． mpg %&gt;% .$manufacturer %&gt;% head() ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; mpg %&gt;% .[[&quot;manufacturer&quot;]] %&gt;% head() ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; mpg %&gt;% .[&quot;manufacturer&quot;] %&gt;% head() ## # A tibble: 6 × 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 audi ## 3 audi ## 4 audi ## 5 audi ## 6 audi [[ ]]と[ ]は，それぞれ[[と[という関数であるため，以下のように書くことができる． この場合，第1引数がパイプの前から引き継がれるため，.を明示しなくてもよい． mpg %&gt;% `$`(manufacturer) %&gt;% head() ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; mpg %&gt;% `[[`(&quot;manufacturer&quot;) %&gt;% head() # mpg %&gt;% `[[`(., &quot;manufacturer&quot;) と同じ ## [1] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; mpg %&gt;% `[`(&quot;manufacturer&quot;) %&gt;% head() ## # A tibble: 6 × 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 audi ## 3 audi ## 4 audi ## 5 audi ## 6 audi 5.5 パイプ以外の関数 magrittrにはパイプとともに使うと便利な関数も含まれている． 例えば，パイプを使ったコードの中で列名を変更したいことがある． set_colnames()はデータフレームの列名を変更する時に便利だ． これを使わずに列名を変更しようとすると，ちょっとトリッキーな関数colnames&lt;-()を使うか，途中でコードを区切る必要がある． hoge &lt;- dplyr::select(mpg, 1:2) cnames &lt;- c(&quot;foo&quot;, &quot;bar&quot;) # colnames(hoge) &lt;- cnames # 通常のコード `colnames&lt;-`(hoge, cnames) # トリッキーなコード hoge %&gt;% magrittr::set_colnames(cnames) 5.6 おまけ：magrittrの不思議な関数たち magrittrには以下のような関数もある． not # `!`，`n&#39;est pas`(フランス語)も同じ add # `+` subtract # `-` multiply_by # `*` divide_by # `/` and # `&amp;` or # `|` equals # `==` ?notとすれば，似たような不思議な関数の一覧と説明が出てくる． パイプと一緒に使うとaddであれば，+と同じ機能であるがパイプの中でつかたときに若干読みやすい気がする． 1:10 %&gt;% `+`(100) ## [1] 101 102 103 104 105 106 107 108 109 110 1:10 %&gt;% add(100) ## [1] 101 102 103 104 105 106 107 108 109 110 "],["tidyverse.html", "Chap. 6 tidyverseを使う 6.1 準備 6.2 tidyverseとは 6.3 tibbleでデータフレームを使いやすくする 6.4 tidyrでデータを整形する 6.5 readrでファイルの保存と読み込み 6.6 dplyrでデータフレームを操作する", " Chap. 6 tidyverseを使う 6.1 準備 install.packages(&quot;tidyverse&quot;) library(tidyverse) 6.2 tidyverseとは tidyverseは単一のパッケージではなく，9つのパッケージを含むパッケージ群である． dplyr：データフレーム操作 forcats：ファクター(因子)操作 ggplot2：作図 lubridate：日付・時間データ purrr：繰り返し処理 readr：ファイル読み込み・保存 stringr：文字列 tibble：データフレームの拡張型 tidyr：整然(tidy)データのツール このうち，この文書ではファクター(因子)をほとんど扱っていないため，forcatsについては説明しない． ggplot2とlubridateはそれぞれ第?章と第?章で説明し，その他はこの章で説明する． 以下では全体に関係するものから説明するため，上記の順序とは異なる(上記はアルファベット順)． 6.3 tibbleでデータフレームを使いやすくする 6.3.1 データフレームとtibble tidyvrseでは，データフレーム(data.frame)をさらに拡張して使いやすくした tbl_dfやtblという形式を基本的に使う． ふつうに使っている限りはそれほど大きな違いはない． 違いないというよりも，オブジェクト名そのものやprint()で内容を表示させたときに見やすいという利点がある． 例えば，各列のデータのタイプが表示される． int(整数)やchr(文字列)のように省略して表示されるので，若干の慣れが必要である． 6.3.2 tibbleの気の利いた表示 画面の幅に表示を合わせてくれるのも良い点である． 例えば，次のように画面の幅に収まりきらない場合でも，データフレームではダラダラと表示を続ける． 一方，tibbleでは画面の幅に入る範囲に「良い感じ」にまとめて表示してくれる． それでも表示できなかった場合は，最後に列名とその形式を出力する． n &lt;- 3 ncol &lt;- 10 cnames &lt;- letters[seq(ncol)] df &lt;- matrix(rnorm(n * ncol), ncol = ncol, dimnames = list(seq(n), cnames)) %&gt;% as.data.frame() %&gt;% print() ## a b c d e f g ## 1 1.4541827 -0.5155210 0.4114891 -0.6899162 0.5098256 -0.1852403 1.14740153 ## 2 -0.3406681 -0.1766051 2.0284599 0.3660587 1.0811949 -0.6193950 0.72016359 ## 3 -0.8510326 -0.7500026 -0.4935498 -1.1920691 0.3573182 -0.3769595 0.06866274 ## h i j ## 1 -0.08216536 -2.9532471 -1.4405979 ## 2 -0.24750300 -0.5846238 1.1758900 ## 3 -0.21116567 -0.4045150 -0.4482902 tibble::as_tibble(df) ## # A tibble: 3 × 10 ## a b c d e f g h i j ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.45 -0.516 0.411 -0.690 0.510 -0.185 1.15 -0.0822 -2.95 -1.44 ## 2 -0.341 -0.177 2.03 0.366 1.08 -0.619 0.720 -0.248 -0.585 1.18 ## 3 -0.851 -0.750 -0.494 -1.19 0.357 -0.377 0.0687 -0.211 -0.405 -0.448 変なたとえかもしれないが，データフレームは「言われたことをそのままやりました」という何も考えずに与えられたことをするような感じで，tibbleは「見やすく修正しておきました」という非常に気の利いた対応をする感じである． さらに，tibbleでは行数が多いときは最初の10行だけ表示する． データフレームではすべてのデータを表示させるので，巨大なデータのときに，画面がやたらスクロールして困った経験があるかもしれない． tibbleではそれがない． なお，行数と列数は最初に書かれている． n &lt;- 21 ncol &lt;- 3 cnames &lt;- letters[seq(ncol)] df &lt;- matrix(rnorm(n * ncol), ncol = ncol, dimnames = list(seq(n), cnames)) %&gt;% as.data.frame() %&gt;% print() ## a b c ## 1 -0.42923729 -1.42959603 0.76122282 ## 2 0.73441151 -0.15799508 -0.29590620 ## 3 -0.88760797 -1.62495121 0.32766158 ## 4 -0.24620294 1.17825777 0.19110809 ## 5 0.67301912 -1.19962860 0.12992183 ## 6 1.29881437 -2.18501763 0.93553945 ## 7 -0.20233212 -0.27904702 -0.64657551 ## 8 -1.46324470 1.28077921 -0.24451780 ## 9 0.52359340 1.00301973 -0.25809022 ## 10 0.01248275 0.25797495 0.42687835 ## 11 -0.58460385 -0.30570855 0.68108704 ## 12 -0.30617006 0.49448883 -0.32239605 ## 13 -0.38553193 1.85757798 -0.25035542 ## 14 -1.09370602 -0.36667886 0.82328200 ## 15 -0.38310473 -0.99521233 -1.42935907 ## 16 -0.80994237 -0.20604959 0.02534643 ## 17 0.91455643 1.19623410 -0.53650297 ## 18 -0.55696668 -0.06473492 0.80025996 ## 19 0.05680071 -1.05417451 -0.15067117 ## 20 2.02344741 0.42402570 0.18682486 ## 21 1.33850047 -0.39038468 1.54876201 tibble::as_tibble(df) ## # A tibble: 21 × 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.429 -1.43 0.761 ## 2 0.734 -0.158 -0.296 ## 3 -0.888 -1.62 0.328 ## 4 -0.246 1.18 0.191 ## 5 0.673 -1.20 0.130 ## 6 1.30 -2.19 0.936 ## 7 -0.202 -0.279 -0.647 ## 8 -1.46 1.28 -0.245 ## 9 0.524 1.00 -0.258 ## 10 0.0125 0.258 0.427 ## # ℹ 11 more rows 表示したい行数を指定するには，引数nで指定する． 以下のコードのうち，3つ目を実行すると全行が表示されるので以下では表示を省略している． mpg # 通常表示 print(mpg, n = 30) # 30行を表示 print(n = nrow(mpg)) # 全行を表示 6.3.3 tibbleへの変換，tibbleの生成 すでにデータフレームがある場合は，as_tibble()でtibbleへの変換ができる． head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 tibble::as_tibble(mtcars) ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ℹ 22 more rows 新たにtibbleを生成するには，データフレームの場合と同様である． n &lt;- 10 data.frame(x = runif(n), y = rnorm(n)) ## x y ## 1 0.43781877 0.1496748 ## 2 0.68690004 -1.1448297 ## 3 0.11373682 2.5023126 ## 4 0.88009486 0.8324161 ## 5 0.06582433 -1.1899489 ## 6 0.93513257 -1.3559714 ## 7 0.42353234 -0.9188516 ## 8 0.84786680 0.3824544 ## 9 0.31866349 -0.7139692 ## 10 0.29392381 0.4354961 tibble::tibble(x = runif(n), y = rnorm(n)) ## # A tibble: 10 × 2 ## x y ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.522 0.915 ## 2 0.0650 -1.06 ## 3 0.210 0.0919 ## 4 0.210 -0.657 ## 5 0.546 1.09 ## 6 0.299 -0.571 ## 7 0.0810 0.302 ## 8 0.900 -0.928 ## 9 0.169 -0.985 ## 10 0.877 0.0588 6.4 tidyrでデータを整形する tidyverseのtidyとは，整然としたという意味である． データフレームやtibbleなっていればtidyかといえば，そうとは限らない． エクセルなどのスプレッド形式にデータが保存されていてもtidyではないのと同様である． tidyデータとは，次の4つを満たすもので，データベースの第3正規と同様のものである． 1 1つの変数が1つの列を構成する 2 1つの観測が1つの行を構成する 3 1つのタイプの観測群が1つの表を構成する 4 1つの値が1つのセルを構成する 例えば，次のデータhouseholdは非整然(messy，tidyの対義語)データの典型的な例である． relig_income ## # A tibble: 18 × 11 ## religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Agnostic 27 34 60 81 76 137 122 ## 2 Atheist 12 27 37 52 35 70 73 ## 3 Buddhist 27 21 30 34 33 58 62 ## 4 Catholic 418 617 732 670 638 1116 949 ## 5 Don’t … 15 14 15 11 10 35 21 ## 6 Evangel… 575 869 1064 982 881 1486 949 ## 7 Hindu 1 9 7 9 11 34 47 ## 8 Histori… 228 244 236 238 197 223 131 ## 9 Jehovah… 20 27 24 24 21 30 15 ## 10 Jewish 19 19 25 25 30 95 69 ## 11 Mainlin… 289 495 619 655 651 1107 939 ## 12 Mormon 29 40 48 51 56 112 85 ## 13 Muslim 6 7 9 10 9 23 16 ## 14 Orthodox 13 17 23 32 32 47 38 ## 15 Other C… 9 7 11 13 13 14 18 ## 16 Other F… 20 33 40 46 49 63 46 ## 17 Other W… 5 2 3 4 2 7 3 ## 18 Unaffil… 217 299 374 365 341 528 407 ## # ℹ 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, ## # `Don&#39;t know/refused` &lt;dbl&gt; 宗教と所得についてのデータである． 1列目の宗教は問題ないが，所得という変数が1つの列ではなく2列目以降の複数の列に広がっている． これを整理するには，pivot_longer()を使う． 1つ目の引数にはデータフレームを指定する． ここではrelig_incomeだが，パイプが用いられているので省略されている colsには整形する列を指定する． ここでは，!religionでreligion以外を指定している． names_toには列名をもとに作る新たな変数(列)名を， values_toにはデータの値をもとに作る新たな変数(列)名を文字列で指定する． relig_income %&gt;% tidyr::pivot_longer( cols = !religion, names_to = &quot;income&quot;, values_to = &quot;count&quot; ) ## # A tibble: 180 × 3 ## religion income count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Agnostic &lt;$10k 27 ## 2 Agnostic $10-20k 34 ## 3 Agnostic $20-30k 60 ## 4 Agnostic $30-40k 81 ## 5 Agnostic $40-50k 76 ## 6 Agnostic $50-75k 137 ## 7 Agnostic $75-100k 122 ## 8 Agnostic $100-150k 109 ## 9 Agnostic &gt;150k 84 ## 10 Agnostic Don&#39;t know/refused 96 ## # ℹ 170 more rows pivot_longer()で出力されたデータフレームは，それぞれの変数が1列に，それぞれの観測が1行になった． 3つ目と4つ目の条件にもがっていしており，これで，tidyデータの条件を満たすことができた． 基本的にはプログラミングの際にはtidyな状態にしておくのが便利である． ただし，入手データがtidyではないことはよくある． また，関数によってはtidyではないオブジェクトを入力する必要やプログラム途中でtidyではない方が都合が良いこともある． tidyではないものからtidyなものへの変換，あるいはその逆をするのに便利な関数がtidyrには多くある． 次のコードでパッケージ内の関数一覧が取得できる． ls(&quot;packages:tidyr&quot;) 以下も参考にしてほしい． https://tidyr.tidyverse.org/ 6.5 readrでファイルの保存と読み込み tidyな状態に整理したデータをファイルとして保存や読み込みをするには，readrの関数を使うのが良い． baseのwrite.table()やread.table()よりも使いやすく，読み込んだデータをtibble形式にしてくれるのが良い． 保存するときは，write_csv(カンマ区切り)やwrite_tsv(タブ区切り)を使う． readr::write_csv(mpg, file = &quot;file_path&quot;) readr::write_tsv(mpg, file = &quot;file_path&quot;) 読み込むときは，read_csv(カンマ区切り)やread_tsv(タブ区切り)を使う． 各列のデータ形式を指定したい場合は，col_typesを使う． readr::read_csv(&quot;file_path&quot;) readr::read_tsv(&quot;file_path&quot;) ここでは，第?章で保存したデータを読み込む． pkgs &lt;- readr::read_tsv(&quot;pkgs.txt&quot;, show_col_types = FALSE) pkgs ## # A tibble: 19,530 × 2 ## pkg description ## &lt;chr&gt; &lt;chr&gt; ## 1 A3 Accurate, Adaptable, and Accessible Error Metrics for Predicti… ## 2 AalenJohansen Conditional Aalen-Johansen Estimation ## 3 AATtools Reliability and Scoring Routines for the Approach-Avoidance Ta… ## 4 ABACUS Apps Based Activities for Communicating and Understanding Stat… ## 5 abbreviate Readable String Abbreviation ## 6 abbyyR Access to Abbyy Optical Character Recognition (OCR) API ## 7 abc Tools for Approximate Bayesian Computation (ABC) ## 8 abc.data Data Only: Tools for Approximate Bayesian Computation (ABC) ## 9 ABC.RAP Array Based CpG Region Analysis Pipeline ## 10 ABCanalysis Computed ABC Analysis ## # ℹ 19,520 more rows col_typesでタイプを指定していないと色々と表示されて面倒なので，show_col_types = FALSEで表示を抑制している． 他にも読み込み時のオプションがあるので，?read_tsvで確認してほしい． なお，エクセルのファイルを読み込むパッケージには，readxlがある． 6.6 dplyrでデータフレームを操作する dplyrはデータフレームを操作するためのパッケージである． 列の追加や選択，行の抽出や並べ替え，グループ化，集計などができる． なお，dplyrの関数名の多くはSQLを参考にしていると思われるので，SQLを使ったことがあればコードの内容を理解しやすいだろう． 6.6.1 CRANのパッケージを分類する ここでは，読み込んだデータフレームpkgsのCRANに登録されているパッケージを分類する． mutate()を使って，descriptionに特定の文字列が含まれるかを判定して，その結果を真偽値の新しい列として追加する． まずはstr_detect()でdescriptionの列に”ocr”を含むかどうかをTRUEまたはFALSEで返す． その結果をocrという列として新たに追加する． pkgs %&gt;% dplyr::mutate(ocr = stringr::str_detect(description, &quot;ocr&quot;)) ## # A tibble: 19,530 × 3 ## pkg description ocr ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 A3 Accurate, Adaptable, and Accessible Error Metrics for Pr… FALSE ## 2 AalenJohansen Conditional Aalen-Johansen Estimation FALSE ## 3 AATtools Reliability and Scoring Routines for the Approach-Avoida… FALSE ## 4 ABACUS Apps Based Activities for Communicating and Understandin… FALSE ## 5 abbreviate Readable String Abbreviation FALSE ## 6 abbyyR Access to Abbyy Optical Character Recognition (OCR) API FALSE ## 7 abc Tools for Approximate Bayesian Computation (ABC) FALSE ## 8 abc.data Data Only: Tools for Approximate Bayesian Computation (A… FALSE ## 9 ABC.RAP Array Based CpG Region Analysis Pipeline FALSE ## 10 ABCanalysis Computed ABC Analysis FALSE ## # ℹ 19,520 more rows mutate()での新しい列名は，「“」を使わずに指定する． 対話的に使っているときには，このように列名を直接入力するのが楽である． なお，「”」を使わずに列名を変数名のように指定(評価)する方法をNSE(Non Standard Evaluation，非標準評価)という． ただし，プログラミングの途中で使っているときには列名が一義的に決まらず，入力したデータの列名を使いたいことがある． そのような時には，all_of(“colnames”)のように文字列として列名を指定したほうが良いことがある． また，mutate()に似た関数としてtransmute()がある． transmute()は，関数内で指定した列以外は削除する点がmutate()とは異なる． 上のコードでは，1つの文字列に対して列を追加した． ここでは複数の文字列に対して同じことをするために，関数を作成する． mutate()の内部がややトリッキーな事になっているが，実行内容は上と同じである． 意味としては，str_detect()で出力した真偽値をkwdの文字列の中身を列名として新たな列を追加している． 関数内では，新しい列名をNSEではなく，文字列として標準評価として用いるために，列名の文字列を{{}}で囲っている． 同様の理由で=ではなく:=というrlangパッケージの関数を使っている． また，str_detect()内で.data[[col]]としている． これは，文字列で列を選択するときに使用する手法である． # キーワードを列名として追加する関数，合致するときはTRUE add_kwd &lt;- function(df, col, kwd){ pattern &lt;- stringr::regex(kwd, ignore_case = TRUE) df %&gt;% dplyr::mutate(`:=`({{kwd}}, stringr::str_detect(.data[[col]], pattern))) } # キーワードの一覧 kwds &lt;- c(&quot;database&quot;, &quot;excel&quot;, &quot;file&quot;, &quot;ggplot&quot;, &quot;image|magick&quot;, &quot;keyboards|mouse&quot;, &quot;ocr&quot;, &quot;office&quot;, &quot;pdf&quot;, &quot;python&quot;, &quot;scrape|scraping|selenium&quot;, &quot;shell&quot;) # キーワード列の追加 for(i in seq_along(kwds)){ pkgs &lt;- add_kwd(pkgs, &quot;description&quot;, kwds[i]) } pkgs ## # A tibble: 19,530 × 14 ## pkg description database excel file ggplot `image|magick` ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 A3 Accurate, Adaptable… FALSE FALSE FALSE FALSE FALSE ## 2 AalenJohansen Conditional Aalen-J… FALSE FALSE FALSE FALSE FALSE ## 3 AATtools Reliability and Sco… FALSE FALSE FALSE FALSE FALSE ## 4 ABACUS Apps Based Activiti… FALSE FALSE FALSE FALSE FALSE ## 5 abbreviate Readable String Abb… FALSE FALSE FALSE FALSE FALSE ## 6 abbyyR Access to Abbyy Opt… FALSE FALSE FALSE FALSE FALSE ## 7 abc Tools for Approxima… FALSE FALSE FALSE FALSE FALSE ## 8 abc.data Data Only: Tools fo… FALSE FALSE FALSE FALSE FALSE ## 9 ABC.RAP Array Based CpG Reg… FALSE FALSE FALSE FALSE FALSE ## 10 ABCanalysis Computed ABC Analys… FALSE FALSE FALSE FALSE FALSE ## # ℹ 19,520 more rows ## # ℹ 7 more variables: `keyboards|mouse` &lt;lgl&gt;, ocr &lt;lgl&gt;, office &lt;lgl&gt;, ## # pdf &lt;lgl&gt;, python &lt;lgl&gt;, `scrape|scraping|selenium` &lt;lgl&gt;, shell &lt;lgl&gt; 列がたくさんできたので，そのうちのいくつかを選択および抽出してみよう． データフレームの特定の列を選択するには，select()を使う． select()でもNSEが使えるので，列名をそのまま入力する． 特定の列を除きたいときは，-あるいは!を使う． なお，文字列で列を指定するには，all_of()とany_of()を使うことができる． さらに，starts_with()やends_with()，contains()などもある． filter()は，データフレームから条件に合致した行を抽出する． 最も単純な抽出方法はocr == TRUEのように真偽値(logical，TRUE か FALSE)として判定されるものであれば，どのようなものでも構わない． 次のコードの場合は，そもそもocrが真偽値なので，ocr == TRUEとせずにocrとしても同じ結果を得られる． pkgs %&gt;% dplyr::select(pkg, description, ocr) %&gt;% dplyr::filter(ocr == TRUE) ## # A tibble: 10 × 3 ## pkg description ocr ## &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 abbyyR &quot;Access to Abbyy Optical Character Recognition (OCR… TRUE ## 2 coalitions &quot;Bayesian \\&quot;\\&quot;Now-Cast\\&quot;\\&quot; Estimation of Event Prob… TRUE ## 3 elastes &quot;Elastic Full Procrustes Means for Sparse and Irreg… TRUE ## 4 googleCloudVisionR &quot;Access to the &#39;Google Cloud Vision&#39; API for Image … TRUE ## 5 paco &quot;Procrustes Application to Cophylogenetic Analysis&quot; TRUE ## 6 pcv &quot;Procrustes Cross-Validation&quot; TRUE ## 7 ProcMod &quot;Informative Procrustean Matrix Correlation&quot; TRUE ## 8 RSocrata &quot;Download or Upload &#39;Socrata&#39; Data Sets&quot; TRUE ## 9 soql &quot;Helps Make Socrata Open Data API Calls&quot; TRUE ## 10 tesseract &quot;Open Source OCR Engine&quot; TRUE dplyr::select(pkgs, -description) # dplyr::select(pkgs, !description)も同じ ## # A tibble: 19,530 × 13 ## pkg database excel file ggplot `image|magick` `keyboards|mouse` ocr ## &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 A3 FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 2 AalenJoha… FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 3 AATtools FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 4 ABACUS FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 5 abbreviate FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 6 abbyyR FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## 7 abc FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 8 abc.data FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 9 ABC.RAP FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## 10 ABCanalys… FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## # ℹ 19,520 more rows ## # ℹ 5 more variables: office &lt;lgl&gt;, pdf &lt;lgl&gt;, python &lt;lgl&gt;, ## # `scrape|scraping|selenium` &lt;lgl&gt;, shell &lt;lgl&gt; お気づきかもしれないがpkgsはtidyではないので，ここで整形しておく． pkgs &lt;- tidyr::pivot_longer(pkgs, cols = -c(pkg, description), names_to = &quot;kwd&quot;, values_to = &quot;val&quot;) %&gt;% dplyr::filter(val) %&gt;% print() ## # A tibble: 958 × 4 ## pkg description kwd val ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 abbyyR Access to Abbyy Optical Character Recognition (… ocr TRUE ## 2 abjData Databases Used Routinely by the Brazilian Jurim… data… TRUE ## 3 ABPS The Abnormal Blood Profile Score to Detect Bloo… file TRUE ## 4 ace2fastq ACE File to FASTQ Converter file TRUE ## 5 AcousticNDLCodeR Coding Sound Files for Use with NDL file TRUE ## 6 activPAL Advanced Processing and Chart Generation from a… file TRUE ## 7 ADAPTS Automated Deconvolution Augmentation of Profile… file TRUE ## 8 add2ggplot Add to &#39;ggplot2&#39; ggpl… TRUE ## 9 adepro A &#39;shiny&#39; Application for the (Audio-)Visualiza… file TRUE ## 10 adfExplorer Import from and Export to Amiga Disk Files file TRUE ## # ℹ 948 more rows tidyになったデータフレームを集計する． group_by()は，指定した列のカテゴリーに従って，グループ化する． ここでは，kwdの文字列でグループ化している． print()で表示させるとGroups: kwd [12]となっており，kwdによって12のグループになっていることがわかる． なお，グループ化を解除するには，ungroup()を用いる． その後，summarise()でグループごとの集計ができる． n()でグループごとの行数を計算する． なお，tally()はsummarise(n = n())のショートカットである． arrange()は，指定した列のデータの順序に従って並べ替えをする． 何も指定しなければ昇順，desc()で列名を指定すれば降順で並べ替えができる． pkgs %&gt;% dplyr::filter(val) %&gt;% dplyr::group_by(kwd) %&gt;% print() %&gt;% dplyr::summarise(n = n()) %&gt;% # tally()も同じ print() %&gt;% dplyr::arrange(desc(n)) ## # A tibble: 958 × 4 ## # Groups: kwd [12] ## pkg description kwd val ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 abbyyR Access to Abbyy Optical Character Recognition (… ocr TRUE ## 2 abjData Databases Used Routinely by the Brazilian Jurim… data… TRUE ## 3 ABPS The Abnormal Blood Profile Score to Detect Bloo… file TRUE ## 4 ace2fastq ACE File to FASTQ Converter file TRUE ## 5 AcousticNDLCodeR Coding Sound Files for Use with NDL file TRUE ## 6 activPAL Advanced Processing and Chart Generation from a… file TRUE ## 7 ADAPTS Automated Deconvolution Augmentation of Profile… file TRUE ## 8 add2ggplot Add to &#39;ggplot2&#39; ggpl… TRUE ## 9 adepro A &#39;shiny&#39; Application for the (Audio-)Visualiza… file TRUE ## 10 adfExplorer Import from and Export to Amiga Disk Files file TRUE ## # ℹ 948 more rows ## # A tibble: 12 × 2 ## kwd n ## &lt;chr&gt; &lt;int&gt; ## 1 database 155 ## 2 excel 25 ## 3 file 364 ## 4 ggplot 165 ## 5 image|magick 153 ## 6 keyboards|mouse 6 ## 7 ocr 10 ## 8 office 19 ## 9 pdf 24 ## 10 python 18 ## 11 scrape|scraping|selenium 15 ## 12 shell 4 ## # A tibble: 12 × 2 ## kwd n ## &lt;chr&gt; &lt;int&gt; ## 1 file 364 ## 2 ggplot 165 ## 3 database 155 ## 4 image|magick 153 ## 5 excel 25 ## 6 pdf 24 ## 7 office 19 ## 8 python 18 ## 9 scrape|scraping|selenium 15 ## 10 ocr 10 ## 11 keyboards|mouse 6 ## 12 shell 4 ここでは紹介しなかったが他の有用な関数として，2つのデータフレームを列の内容に合わせて結合(マージ)するleft_join()がある． これににた関数として，右側の引数(つまり第2引数)をもとにして結合するright_join()，全結合するfull_join()，マッチしなかった行を返すanti_join()などがある． 詳しい使い方は，ヘルプを参照してほしい． また，重複行を除去するdistinct()もよく使う関数である． "],["stringr.html", "Chap. 7 stringrで文字列操作 7.1 はじめに 7.2 準備 7.3 stringrの主な関数 7.4 活用例", " Chap. 7 stringrで文字列操作 7.1 はじめに stringrはstringiパッケージのラッパーである． stringiは文字列操作のパッケージで，文字コードの変換などを含む多様な関数を含んでいる． 通常のユーザの文字列操作なら，stringrで大丈夫なことが多い． 万が一，込み入った文字列操作が必要なときは，stringiの関数を探してみると良いだろう． stringrには， 少なくとも自分の経験では，stringrだけで操作が完結することはほとんどない． 逆に，パッケージ開発をしていてstringr(やdplyr)を使わずに一日が終わることもあまりない． つまり，stringrはかなり便利で必要不可欠なツールである． もちろんbaseパッケージの同様の関数を使っても機能上は問題ないことが多い． しかし，引数の指定方法に一貫性があると，コードを綺麗に書くことができる． 綺麗なコードは，汚いコードよりも書きやすく，見た目が良く，何よりもバグが入りにくい(入らないわけではない)． 7.2 準備 install.packages(&quot;stringr&quot;) library(tidyverse) library(stringr) # 本来は不要 library(fs) 7.3 stringrの主な関数 stringrでは主な関数はstr_で始まるようになっている． これらの一覧は次のとおりである． ちなみに，str_subset()で正規表現に合致した要素だけを返している． ls(&quot;package:stringr&quot;) %&gt;% stringr::str_subset(&quot;^str_&quot;) ## [1] &quot;str_c&quot; &quot;str_conv&quot; &quot;str_count&quot; ## [4] &quot;str_detect&quot; &quot;str_dup&quot; &quot;str_ends&quot; ## [7] &quot;str_equal&quot; &quot;str_escape&quot; &quot;str_extract&quot; ## [10] &quot;str_extract_all&quot; &quot;str_flatten&quot; &quot;str_flatten_comma&quot; ## [13] &quot;str_glue&quot; &quot;str_glue_data&quot; &quot;str_interp&quot; ## [16] &quot;str_length&quot; &quot;str_like&quot; &quot;str_locate&quot; ## [19] &quot;str_locate_all&quot; &quot;str_match&quot; &quot;str_match_all&quot; ## [22] &quot;str_order&quot; &quot;str_pad&quot; &quot;str_rank&quot; ## [25] &quot;str_remove&quot; &quot;str_remove_all&quot; &quot;str_replace&quot; ## [28] &quot;str_replace_all&quot; &quot;str_replace_na&quot; &quot;str_sort&quot; ## [31] &quot;str_split&quot; &quot;str_split_1&quot; &quot;str_split_fixed&quot; ## [34] &quot;str_split_i&quot; &quot;str_squish&quot; &quot;str_starts&quot; ## [37] &quot;str_sub&quot; &quot;str_sub_all&quot; &quot;str_sub&lt;-&quot; ## [40] &quot;str_subset&quot; &quot;str_to_lower&quot; &quot;str_to_sentence&quot; ## [43] &quot;str_to_title&quot; &quot;str_to_upper&quot; &quot;str_trim&quot; ## [46] &quot;str_trunc&quot; &quot;str_unique&quot; &quot;str_view&quot; ## [49] &quot;str_view_all&quot; &quot;str_which&quot; &quot;str_width&quot; ## [52] &quot;str_wrap&quot; また，合致した以外のものを返すには，negate = TRUEとする． ls(&quot;package:stringr&quot;) %&gt;% stringr::str_subset(&quot;^str_&quot;, negate = TRUE) ## [1] &quot;%&gt;%&quot; &quot;boundary&quot; &quot;coll&quot; &quot;fixed&quot; &quot;fruit&quot; ## [6] &quot;invert_match&quot; &quot;regex&quot; &quot;sentences&quot; &quot;word&quot; &quot;words&quot; このうちfruits，words，sentencesは，それぞれ果物の名前，一般的な単語，文のサンプルデータである． fixed()は正規表現を使わずに，文字列を正規表現ではなくそのままの文字列として使う関数である． これら以外のものについて知りたい場合は，ヘルプを参照して欲しい． # stringr::str_detect() # stringr::str_replace_all() # stringr::str_c() # stringr::str_detect() # stringr::str_extract_all() # stringr::str_length() # stringr::str_split() # stringr::str_subset() # stringr::str_sub() # stringr::str_dup() # stringr::str_extract() # stringr::str_pad() # stringr::str_trunc() # stringr::str_replace_all() # stringr::str_to_lower() 7.4 活用例 # fs::dir_ls() # パッケージ名の一覧を検索するという活用例 # fs::dir_ls(regexp = &quot;Rmd&quot;) # install.packages(&quot;&quot;) # library() # pkg::fun() # stringr::fixed() # stringr::regex() # fs.Rmd # fs::path_dir(&quot;path&quot;) # パスからディレクトリ名抽出 # fs::path_file(&quot;path&quot;) # パスからファイル名抽出 # fs::path_ext(&quot;path&quot;) # パスから拡張子抽出 # fs::path_ext_remove(&quot;path&quot;) # パスから拡張子を削除 # path_ext_set(&quot;path&quot;, &quot;new_ext&quot;) # 拡張子変更 "],["lubridate.html", "Chap. 8 lubridateで日付・時刻を扱う 8.1 準備 8.2 1月後・1年後の同一日 8.3 文字列からDateクラスへの変換 8.4 曜日を求める 8.5 活用例", " Chap. 8 lubridateで日付・時刻を扱う 年月日や曜日を扱う場合，パッケージlubridateを利用するのが便利である． lubridateは，tidyverseに含まれているパッケージの1つで，日付や時刻・時間データを扱う際には必須と言っても過言ではない． 8.1 準備 例によってパッケージのインストールと呼び出しだが，lubridateはtidyverseに含まれている． そのため，tidyverseを呼び出せばそれでOKである． 日付の確認用としてカレンダーを最後に表示する． そのためのパッケージであるcalendRをインストールしておく． install.packages(&quot;calendR&quot;) library(tidyverse) library(calendR) 8.2 1月後・1年後の同一日 例えば，1月後や1年後の同一の日付を得たいとする． これは単純なようで実はややこしい問題を含んでいる． 月には大の月・小の月があるし，年には閏年がある． そのため，同一日がないときがあるため，自分で関数を作成するにはこれらを考慮しなければならない． lubridateを活用すると簡単に計算できる． 1年後の同一の日付を得るには+ years(1)とすれば良い． 単純に365日加えるのとは結果が異なる． 1月後の場合にはmonths(1)を使う today() + years(0:4) ## [1] &quot;2023-05-26&quot; &quot;2024-05-26&quot; &quot;2025-05-26&quot; &quot;2026-05-26&quot; &quot;2027-05-26&quot; today() + days(365 * 0:4) ## [1] &quot;2023-05-26&quot; &quot;2024-05-25&quot; &quot;2025-05-25&quot; &quot;2026-05-25&quot; &quot;2027-05-25&quot; today() + months(0:4) ## [1] &quot;2023-05-26&quot; &quot;2023-06-26&quot; &quot;2023-07-26&quot; &quot;2023-08-26&quot; &quot;2023-09-26&quot; today() + months(0:4) ## [1] &quot;2023-05-26&quot; &quot;2023-06-26&quot; &quot;2023-07-26&quot; &quot;2023-08-26&quot; &quot;2023-09-26&quot; 8.3 文字列からDateクラスへの変換 日本語の表記でよく出てくる年・月・日の順の日付表記は，関数ymd()でDateクラスに変換できる． ymd()は，日付っぽい文字列をDateクラスにしてくれる． よく使うような以下の文字列は，普通に変換してくれる． ちなみに，日付の後ろに(火)のような曜日が入っていても問題ない(曜日は無視される)． c(&quot;2023年4月10日&quot;, &quot;2023-4-10&quot;, &quot;2023_4_10&quot;, &quot;20230410&quot;, &quot;2023/4/10&quot;) %&gt;% ymd() ## [1] &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; c(&quot;2023年4月10日(月)&quot;, &quot;2023-4-10(月)&quot;, &quot;2023_4_10(月)&quot;, &quot;20230410(月)&quot;, &quot;2023/4/10(月)&quot;) %&gt;% ymd() ## [1] &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; &quot;2023-04-10&quot; 年が入っていない場合はうまくいかないので，年を追加する必要がある． c(&quot;4月10日&quot;, &quot;4/10&quot;) %&gt;% ymd() ## Warning: All formats failed to parse. No formats found. ## [1] NA NA c(&quot;4月10日&quot;, &quot;4/10&quot;) %&gt;% paste0(&quot;2023-&quot;, .) %&gt;% ymd() ## [1] &quot;2023-04-10&quot; &quot;2023-04-10&quot; ここでは日付を中心に扱うが，時刻の計算もうまくやってくれる． ymd_hms(&quot;2023-5-1-12-23-34&quot;) %&gt;% print() %&gt;% `+`(minutes(40)) ## [1] &quot;2023-05-01 12:23:34 UTC&quot; ## [1] &quot;2023-05-01 13:03:34 UTC&quot; 8.4 曜日を求める 日付をもとにwday()を用いて曜日を求めることができる． ただし，デフォルトでは日曜日を1，月曜日を2のように日曜始まりの場合での曜日番号を示す． label = TRUEとすると，factorとしての曜日を返してくれる． x &lt;- today() wday(x) # week of the day ## [1] 6 wday(x, label = TRUE) ## [1] 金 ## Levels: 日 &lt; 月 &lt; 火 &lt; 水 &lt; 木 &lt; 金 &lt; 土 8.5 活用例 日付固定(同じ月日)あるいは位置固定(m月の第nのw曜日)のときでの一年後の年月日を求めることを考える． 日付固定の場合は，既に説明したように非常に簡単に求められる． x &lt;- today() x + years(1) ## [1] &quot;2024-05-26&quot; 位置固定の場合は，関数を作成する必要がある． 年月日から第何の何曜日か分からなければ，位置を固定できない． 曜日はwday()で求められるため，第何の曜日かを求める関数が必要だ． mweek &lt;- function(x){ (mday(x) - 1) %/% 7 + 1 } mday(x)で月の中で何日目か計算し(つまり day(x)と同じ)，そこから1日引いた数字を7で割る． 7で割ったときに第1曜日は1未満，第2曜日は1以上2未満であるため，7で割ったときの整数部分に1を足す． これで第何の曜日かがわかる． real &lt;- seq(as.POSIXct(&quot;2020-10-1&quot;), as.POSIXct(&quot;2020-10-31&quot;), by=&quot;day&quot;) %&gt;% mweek() expect &lt;- rep(1:5, each=7)[1:31] sum(real != expect, na.rm = TRUE) ## [1] 0 念のため計算したrealと求めるべきexpectが同じか確認する． real != expect，つまりrealとexpect異なるときはTRUEになる． この合計が0であれば全部が同じなので，計算結果は正しいといえる． 次に，年月日から1年後の 年と月を分離してそこから求めたい月の1日をbaseの日付とする． 1日から7日までは第1の，8日から14日までは第2の曜日なので，baseに「mweek(x) - 1) * 7」を足してやる． さらに，これに曜日の補正をするため，baseと元の日付(x)との曜日の差を追加する． ただし，差が負の場合は7から引いて正にする． なお，「for(i in seq_along(diff))」でループしている部分は，ベクトルへの対応である． 入力が1日だけの場合は必要ないが，他の部分がベクトルに対応おり，せっかくなので複数の日付(Dateクラスのベクトル)を受け入れるようにした． これで，一応出来上がった． ただし，第5の曜日の場合は，次の月にずれてしまっている可能性がある． そこで，月がずれていないか確認して，ずれている場合は「NA」を返す． same_pos_next_yr &lt;- function(x){ yr &lt;- year(x) mn &lt;- month(x) base &lt;- ymd(paste0(yr + 1, &quot;-&quot;, mn, &quot;-&quot;, 1)) diff &lt;- wday(x) - wday(base) for(i in seq_along(diff)){ if(diff[i] &lt; 0){ diff[i] &lt;- diff[i] + 7 } } same_pos &lt;- base + (mweek(x) - 1) * 7 + diff for(i in seq_along(same_pos)){ if(month(same_pos[i]) != mn[i]){ same_pos[i] &lt;- NA warning(&quot;No same date as &quot;, x[i], &quot;!&quot;) } } return(same_pos) } 実際の日付で確認してみる． days &lt;- today() + (0:30) days_n &lt;- same_pos_next_yr(days) ## Warning in same_pos_next_yr(days): No same date as 2023-05-29! ## Warning in same_pos_next_yr(days): No same date as 2023-05-30! days ## [1] &quot;2023-05-26&quot; &quot;2023-05-27&quot; &quot;2023-05-28&quot; &quot;2023-05-29&quot; &quot;2023-05-30&quot; ## [6] &quot;2023-05-31&quot; &quot;2023-06-01&quot; &quot;2023-06-02&quot; &quot;2023-06-03&quot; &quot;2023-06-04&quot; ## [11] &quot;2023-06-05&quot; &quot;2023-06-06&quot; &quot;2023-06-07&quot; &quot;2023-06-08&quot; &quot;2023-06-09&quot; ## [16] &quot;2023-06-10&quot; &quot;2023-06-11&quot; &quot;2023-06-12&quot; &quot;2023-06-13&quot; &quot;2023-06-14&quot; ## [21] &quot;2023-06-15&quot; &quot;2023-06-16&quot; &quot;2023-06-17&quot; &quot;2023-06-18&quot; &quot;2023-06-19&quot; ## [26] &quot;2023-06-20&quot; &quot;2023-06-21&quot; &quot;2023-06-22&quot; &quot;2023-06-23&quot; &quot;2023-06-24&quot; ## [31] &quot;2023-06-25&quot; days_n ## [1] &quot;2024-05-24&quot; &quot;2024-05-25&quot; &quot;2024-05-26&quot; NA NA ## [6] &quot;2024-05-29&quot; &quot;2024-06-06&quot; &quot;2024-06-07&quot; &quot;2024-06-01&quot; &quot;2024-06-02&quot; ## [11] &quot;2024-06-03&quot; &quot;2024-06-04&quot; &quot;2024-06-05&quot; &quot;2024-06-13&quot; &quot;2024-06-14&quot; ## [16] &quot;2024-06-08&quot; &quot;2024-06-09&quot; &quot;2024-06-10&quot; &quot;2024-06-11&quot; &quot;2024-06-12&quot; ## [21] &quot;2024-06-20&quot; &quot;2024-06-21&quot; &quot;2024-06-15&quot; &quot;2024-06-16&quot; &quot;2024-06-17&quot; ## [26] &quot;2024-06-18&quot; &quot;2024-06-19&quot; &quot;2024-06-27&quot; &quot;2024-06-28&quot; &quot;2024-06-22&quot; ## [31] &quot;2024-06-23&quot; 計算できているはずだが，日付だけを見てもよくわからない． 各日付が第何の曜日かを確認してみる． mweek(days) # 第何の曜日か ## [1] 4 4 4 5 5 5 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 3 3 4 4 4 4 mweek(days_n) ## [1] 4 4 4 NA NA 5 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 3 3 3 ## [26] 3 3 4 4 4 4 sum(mweek(days) != mweek(days_n), na.rm = TRUE) ## [1] 0 # testthat::expect_equal(mweek(days), mweek(days_n)) 最後の方でエラーが出ている． さらに，曜日も確認してみる． wday(days, label = TRUE) # 曜日 ## [1] 金 土 日 月 火 水 木 金 土 日 月 火 水 木 金 土 日 月 火 水 木 金 土 日 月 ## [26] 火 水 木 金 土 日 ## Levels: 日 &lt; 月 &lt; 火 &lt; 水 &lt; 木 &lt; 金 &lt; 土 wday(days_n, label = TRUE) ## [1] 金 土 日 &lt;NA&gt; &lt;NA&gt; 水 木 金 土 日 月 火 水 木 金 ## [16] 土 日 月 火 水 木 金 土 日 月 火 水 木 金 土 ## [31] 日 ## Levels: 日 &lt; 月 &lt; 火 &lt; 水 &lt; 木 &lt; 金 &lt; 土 sum(wday(days) != wday(days_n), na.rm = TRUE) ## [1] 0 # testthat::expect_equal(wday(days), wday(days_n)) こちらも，最後の方でエラーが出ている． このエラーは，第5週でずれるためでてくる部分である． ただし，閏年以外の2月だけは4週にピッタリ収まるので，エラーが出ないはずだ． テストもだいたいあっていそうだが，分かりにくいため，カレンダーで表示してみる． weeknames &lt;- c(&quot;M&quot;, &quot;T&quot;, &quot;W&quot;, &quot;T&quot;, &quot;F&quot;, &quot;S&quot;, &quot;S&quot;) title_1 &lt;- paste0(year(x) , &quot;-&quot; ,month(x)) title_2 &lt;- paste0(year(x) + 1, &quot;-&quot; ,month(x)) calendR::calendR(year(x) , month(x), title = title_1, start = &quot;M&quot;, weeknames = weeknames) calendR::calendR(year(x) + 1, month(x), title = title_2, start = &quot;M&quot;, weeknames = weeknames) "],["fs.html", "Chap. 9 fsでファイル操作 9.1 準備 9.2 シェル，baseパッケージ, fsパッケージ 9.3 fsの関数 9.4 fsを使ったファイル操作例 9.5 おまけ：GUIでの作業フォルダの指定", " Chap. 9 fsでファイル操作 Windowsならコマンドプロンプト(古い言い方なら，いわゆるdos窓)，MacならTerminal，Linuxならシェルで，各種ファイル操作をコマンドラインで実行できる． もちろん，マウスを使った操作でも構わないが，名前の変更やファイル名によるフォルダの振り分けを大量にするなら，マウス操作よりもコマンドを使った操作が早いし確実である． なお，Windowsでは [Win] + [R] - [ファイル名を指定して実] - [cmd] でコマンドプロンプトが， Macでは[Command] + [Space] - [Spotlight検索] - [terminal] でTerminalが起動する． コマンドプロンプトやバッチファイル(あるいはシェルスクリプト)などでの操作に慣れていれば，それが便利である． ただ，dosコマンドの変数の扱いは，慣れていないと結構難しい(慣れていても?)． そんなときは，Rの関数(system()やshell())と，dosコマンドを駆使して，ファイル名を取得・名前の変更をすることができる． 既にdosコマンドを書いていれば，system()などを使うのは良い方法である． ただし，複数のOSを使う場合はコマンドが異なるためそれぞれでコマンドを覚えなければならず，またOSとコマンドとの対応で混乱することがある． OSごとに異なるコマンドを覚えるよりも，Rの関数で操作可能ならばどのOSでも同じように動作してくれて楽ができる． Rのbaseパッケージにはファイル操作のための関数が多くある． 例えば，list.files()でファイル名一覧を取得でき，file.rename()でファイル名の変更ができる． しかし，baseの関数は名前が分かりにくい点や引数の一貫性が無い点などの難点がある． これは，Rが発展していく中で徐々に関数が追加されたことによるようだ． fsパッケージでは，baseの関数を整理するとともに，新たな有用な関数が追加されている． そのため，命名規則が一貫しており，ベクトル化した引数を受けとることができる． なお，fs，base，シェルの詳細な比較が，以下のURLにあるので，参照してほしい． https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html 9.1 準備 install.packages(&quot;fs&quot;) library(fs) 9.2 シェル，baseパッケージ, fsパッケージ a.pdf, b.pdf, …, j.pdfを01.pdf, 02.pdf, …, 10.pdfのように10個のファイル名を変更したいとする． 9.2.1 シェルを使う シェルなら，以下のようなコマンドだ． dosコマンドの変数やループなどを駆使すると，もっと短く書けるのかもしれないが，残念ながら私にはそのような技術がない． テキストエディタで書いてもそれほど時間がからないだろうが，ファイル数が多くなれば大変だ． rename a.pdf 01.pdf rename b.pdf 02.pdf rename c.pdf 03.pdf ... rename j.pdf 10.pdf 9.2.2 baseパッケージ Rの標準の関数を使った例は次のとおりである． sprintf()は使い慣れていないと，指定方法が分かりにくい． old &lt;- paste0(letters[1:10], &quot;.pdf&quot;) new &lt;- paste0(sprintf(&quot;%02.f&quot;, 1:10), &quot;.pdf&quot;) file.rename(old, new) 9.2.3 fsパッケージ fsパッケージとともに，stringrを使った例を示す． ファイル操作をする際には，文字列の置換・検索などをすることが多いので，stringrが役立つ． library(stringr) old &lt;- str_c(letters[1:10], &quot;.pdf&quot;) new &lt;- str_c(str_pad(1:10, width = 2, side = &quot;left&quot;, pad = &quot;0&quot;), &quot;.pdf&quot;) file_move(old, new) 9.3 fsの関数 パス操作(path_*)，ディレクトリ操作(dir_*)，ファイル操作(file_*)の関数に分けることができる． パス操作には，baseやシェルにはない機能が多くあって，使いやすい． 拡張子を取り除く関数を自作したことがあるが，同じような関数があることを見つけたときには，下位機能の車輪を再発明してしまったと後悔した． しかも，fsのほうがしっかりしているはずだ． fs，base，シェルの比較は次のURLを参照して欲しい． https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html 9.3.1 パス操作 パス操作はfsパッケージの関数を使うと簡単にできる． 特に，パスからディレクトリ名，ファイル名，拡張子を抽出してくれる関数は便利だ． パス操作の関数を自作するには，自作してもある程度はできるが，stringrを駆使しなければならない． 自作した関数にはバグが入っている可能性がある． 不具合を防ぐためにも，fsパッケージのパス関数を使うほうが良さそうである． path(&quot;top_dir&quot;, &quot;nested_dir&quot;, &quot;file&quot;, ext = &quot;ext&quot;) # パス作成 path_temp(), path_temp(&quot;path&quot;) # 一時パス名の作成 path_expand(&quot;~/path&quot;) # &quot;~&quot;をユーザのホームディレクトリに変換したパス path_dir(&quot;path&quot;) # パスからディレクトリ名抽出 path_file(&quot;path&quot;) # パスからファイル名抽出 path_ext(&quot;path&quot;) # パスから拡張子抽出 path_ext_remove(&quot;path&quot;) # パスから拡張子を削除 path_home() # ホームディレクトリ path_package(&quot;pkgname&quot;, &quot;dir&quot;, &quot;file&quot;) # パッケージのパス名 path_norm(&quot;path&quot;) # 参照や&quot;..&quot;の削除 path_real(&quot;path&quot;) # 実体パス(シンボリックリンクを実体パスに) path_abs(&quot;path&quot;) # 絶対パス path_rel(&quot;path/foo&quot;, &quot;path/bar&quot;) # 相対パス path_common(c(&quot;path/foo&quot;, &quot;path/bar&quot;, &quot;path/baz&quot;)) # パスの共通部分 path_ext_set(&quot;path&quot;, &quot;new_ext&quot;) # 拡張子変更 path_sanitize(&quot;path&quot;) # 無効な文字を削除 path_join(&quot;path&quot;) # 結合 path_split(&quot;path&quot;) # 分割 9.3.2 ディレクトリ操作 シェルやbaseでも同様の機能があるが，複数処理のdir_map()やツリー表示のdir_tree()は単純に嬉しい． dir_ls(&quot;path&quot;) # 一覧 dir_info(&quot;path&quot;) # 情報 dir_copy(&quot;path&quot;, &quot;new-path&quot;) # 複写 dir_create(&quot;path&quot;) # 作成 dir_delete(&quot;path&quot;) # 削除 dir_exists(&quot;path&quot;) # 有無確認 dir_move() (see file_move) # 移動 dir_map(&quot;path&quot;, fun) # 複数処理 dir_tree(&quot;path&quot;) # ツリー表示 9.3.3 ファイル操作 ファイル操作はシェルやbaseとそれほど変わらない感じがする． file_chmod(&quot;path&quot;, &quot;mode&quot;) # 権限変更 file_chown(&quot;path&quot;, &quot;user_id&quot;, &quot;group_id&quot;) # 所有者変更 file_copy(&quot;path&quot;, &quot;new-path&quot;) # 複写 file_create(&quot;new-path&quot;) # 作成 file_delete(&quot;path&quot;) # 削除 file_exists(&quot;path&quot;) # 有無確認 file_info(&quot;path&quot;) # 情報 file_move(&quot;path&quot;, &quot;new-path&quot;) # 移動 file_show(&quot;path&quot;) # 開く file_touch() # アクセス時間等の変更 file_temp() # 一時ファイル名の作成 9.4 fsを使ったファイル操作例 ごく個人的なことだが，Rのバージョンアップ時にはRconsoleとRProfile.siteを古いバージョンから複製して，カスタマイズした設定を引き継いでいる． バージョンアップをそれほど頻繁にしないのであれば，手作業でコピーしてもそれほど問題はない． 普通のRユーザなら常に最新版を使わなくても良い． ただ，パッケージの開発をしていると，開発中のパッケージが依存しているパッケージが最新版のRで開発されている旨の警告がでることが結構ある． ごく最近までは手作業でファイルをコピーしていたが，よく考えたらこういった作業は自動化するべきだと気づいた． そこで，fsパッケージを使ってファイルをコピーするスクリプトを作成した． # Script to copy Rconsole for updating R # RをバージョンアップしたときのRconsoleの複製スクリプト # https://gist.github.com/matutosi/6dab3918402662f081be5c17cc7f9ce2 wd &lt;- fs::path_package(&quot;base&quot;) %&gt;% fs::path_split() %&gt;% unlist() %&gt;% .[-c((length(.) - 2):length(.))] %&gt;% fs::path_join() setwd(wd) dir &lt;- fs::dir_ls(type = &quot;directory&quot;) d_old &lt;- dir[length(dir)-1] d_new &lt;- dir[length(dir)] files &lt;- c(&quot;Rconsole&quot;, &quot;Rprofile.site&quot;) f_old &lt;- fs::path(d_old, &quot;etc&quot;, files) f_new &lt;- fs::path(d_new, &quot;etc&quot;) fs::file_copy(f_old, f_new, overwrite = TRUE) path_package()でbaseパッケージつまりRがインストールされているディレクトリを取得する． 取得したディレクトリを文字列として分割して，その後ろから2つの”library”と”base”を削除して，wd(作業ディレクトリ)とする． 複数のバージョンインストールされているので，dir_ls(type = \"directory\")で各バージョンのディレクトリを取得する． 古いものから順番に入っているので，後ろから2番目と1番後ろのディレクトリをそれぞれd_oldとd_newとする． filesにはコピーしたいファイル名を入れているので，他のファイルをコピーしたい場合は，ここを修正する． 最後に新・旧のファイル名を生成して，file_copy()でファイルをコピーする． このように，定期的あるいはバージョンアップなどに伴うファイルのコピーや移動はそれなりにあるように思う． そのような場合は，fsを活用して作業を自動化するとよいだろう． なお，fsで対応していない部分の文字列操作には，stringrを使うと便利である． 9.5 おまけ：GUIでの作業フォルダの指定 GUI(Graphical User Interface)，つまりマウス操作による作業フォルダを指定するには，tcltkパッケージを使うと良い． tcltkパッケージは，Rをインストールすると既に入っているので，インストールの必要はない． なお，tkchooseDirectory()で得たオブジェクトをそのままsetwd()で指定するとエラーになるので，fs::path()でパスに変換しておく． getwd() library(tcltk) wd &lt;- tcltk::tkchooseDirectory() setwd(fs::path(wd)) getwd() "],["shell.html", "Chap. 10 system()やshell()でOSコマンドの実行 10.1 準備 10.2 活用例：Pythonとそのライブラリのインストール 10.3 Windowsでのアプリ・ディレクトリの瞬間起動 {#run_in a_second}", " Chap. 10 system()やshell()でOSコマンドの実行 Rからsystem()でOSのコマンドを実行できる(Windowsではshell()も使える)． 例えば，以下のようなことだ． ファイルの移動 PDFファイルの結合 pngからPDFへ変換 Pythonスクリプトの実行 見れば分かるように，これらはこの文書で紹介するパッケージで実行できることとほぼ同じである． この文書の執筆前は，便利なパッケージの存在自体を知らなかったため，かなりsystem()やshell()を使っていた． しかし，便利なパッケージがあるのが分かれば，コマンドを自分で書く必要はない． 便利なものを使うのが良い． わざわざsystem()で実行するならば，自作のバッチファイル(Windows)やシェルスクリプト(MacやLinux)などだろうか． あるいは自分で関数やパッケージを開発する際に使ってみることがあるかもしれない． 一応，こんなこともできるんだという程度に知っておけばよいだろう． 以下では，RからPythonとそのライブラリをインストールする． 普通ならシェルで直接実行するものだが，ここではRをシェルの代わりとして使う． 利点は，Rを起動していれば新たなシェルを起動せずにそのまま実行できること，返り値をRのオブジェクトに代入して使えることである． 欠点は，キー入力が若干増えることである． 10.1 準備 system()やshell()などはRのbaseパッケージに含まれている． ここでは，組み合わせて使用するcurlパッケージをインストールしておく． install.packages(&quot;curl&quot;) library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors library(curl) ## Using libcurl 7.84.0 with Schannel ## ## Attaching package: &#39;curl&#39; ## ## The following object is masked from &#39;package:readr&#39;: ## ## parse_date 10.2 活用例：Pythonとそのライブラリのインストール PythonとそのライブラリのインストールをRから実行してみよう． Pythonを直接使わなくても，インストールしておいて損はない． RにはないライブラリがPythonにはあり，reticulateパッケージを使えばRからPythonを実行できるためだ． ここではさらに，キーボードとマウス操作の自動化で使用するPillowとPyAutoGUIというライブラリをインストールする． 10.2.1 Pythonのイントール まずは，Pythonのインストーラをダウンロードする． Windowsの場合は，以下を実行するとデフォルトのブラウザでPythonのインストラのダウンロードページが開く． なお，ここで利用しているshell.exec()はWindowsで使える関数で，拡張子に関連付けられたファイルを実行するものである． shell.exec(&quot;https://pythonlinks.python.jp/ja/index.html&quot;) MacやLinuxには，通常はデフォルトでPython3がインストールされている． 必要に応じてバージョンアップして欲しい． また，Python2がインストールされていても，使わない場合はアンインストールしておくことをお勧めする． 複数のバージョンがインストールされていると，PythonというコマンドでPython2が起動して混乱を招くおそれがあるためだ． 2023年5月現在でのPythonの最新版は3.11.1なので，以下ではそのファイルのURLを入力している． 最新版が異なる場合は，適宜URLを変更してほしい． curl_downloadで一時ファイルとしてインストーラをダウンロードする． なお，py_installerにはダウンロードした一時ファイル名を保存している． py_installer &lt;- &quot;https://www.python.org/ftp/python/3.11.1/python-3.11.1-amd64.exe&quot; %&gt;% curl::curl_download(fs::file_temp(ext = &quot;exe&quot;)) ダウンロードしたファイルを実行するために，再度shell.exec()を使う． これを実行すると，Pythonのインストーラが起動するので，その指示に従ってPythonをインストールする． 最初のAdd python.exe to PATHにチェックが入っていなければ，追加でチェックをすれば良いだろう． それ以外は，デフォルトのボタンをクリックしていけばOKである． 内容がわかっていて，自分流でインストールしたい場合はカスタマイズすると良い． カスタマイズする場合でも，インストールする項目でpipのチェックは入れたままにしておく． PillowとPyAutoGUIのインストールに使用するからだ． shell.exec(py_installer) これでPythonがインストールできたはずだが，念のため確認しておく． インストールしたバージョンによって表示が若干異なるが，以下のコードを実行してバージョンが表示されれば，Pythonのインストールは成功である． system(&quot;python -V&quot;, intern = TRUE) ## [1] &quot;Python 3.11.1&quot; Pythonのインストールがうまくいかない場合は，以下を参考にして欲しい． https://www.python.jp/install/windows/install.html 10.2.2 PillowとPyAutoGUIのインストール 次に，PillowとPyAutoGUIをインストールする． インストールする前に，インストール済のライブラリを確認する． pip listは，Pythonのライブラリ管理ソフトであるpipを使ってインストール済みライブラリ一覧を出力するコマンドである． 初めてPythonをインストールしたのであれば，一覧に何も表示されないはずなので，PillowとPyAutoGUIをインストールする． もし，一覧の中に”Pillow”と”PyAutoGUI”という文字列があれば，インストールは不要である． cmd &lt;- &quot;pip list&quot; res &lt;- system(cmd, intern = TRUE) tibble::as_tibble(res) %&gt;% dplyr::filter(stringr::str_detect(value, &quot;Pillow|PyAutoGUI&quot;)) ## # A tibble: 0 × 1 ## ℹ 1 variable: value &lt;chr&gt; &gt; cmd &lt;- &quot;pip install Pillow PyAutoGUI&quot; res &lt;- system(cmd, intern = TRUE) head(res) ## [1] &quot;Collecting Pillow&quot; ## [2] &quot; Using cached Pillow-9.5.0-cp311-cp311-win_amd64.whl (2.5 MB)&quot; ## [3] &quot;Collecting PyAutoGUI&quot; ## [4] &quot; Using cached PyAutoGUI-0.9.53-py3-none-any.whl&quot; ## [5] &quot;Requirement already satisfied: pymsgbox in c:\\\\users\\\\username\\\\appdata\\\\local\\\\programs\\\\python\\\\python~1\\\\lib\\\\site-packages (from PyAutoGUI) (1.0.9)&quot; ## [6] &quot;Requirement already satisfied: PyTweening&gt;=1.0.1 in c:\\\\users\\\\username\\\\appdata\\\\local\\\\programs\\\\python\\\\python~1\\\\lib\\\\site-packages (from PyAutoGUI) (1.0.7)&quot; tail(res) ## [1] &quot;Requirement already satisfied: pyperclip in c:\\\\users\\\\username\\\\appdata\\\\local\\\\programs\\\\python\\\\python~1\\\\lib\\\\site-packages (from mouseinfo-&gt;PyAutoGUI) (1.8.2)&quot; ## [2] &quot;Installing collected packages: Pillow, PyAutoGUI&quot; ## [3] &quot;Successfully installed Pillow-9.5.0 PyAutoGUI-0.9.53&quot; ## [4] &quot;&quot; ## [5] &quot;[notice] A new release of pip available: 22.3.1 -&gt; 23.1.2&quot; ## [6] &quot;[notice] To update, run: python.exe -m pip install --upgrade pip&quot; 最後の方に”Successfully installed Pillow-9.5.0 PyAutoGUI-0.9.53”のような表示があればインストールができているはずだ． 念のためpipで確認する． 以下では書き方をわざと変えているが，ライブラリのインストール前と実行内容は同じである． 一覧の中に”Pillow”と”PyAutoGUI”という文字列があれば，インストールされていることが確認できる． &quot;pip list&quot; %&gt;% system(intern = TRUE) %&gt;% tibble::as_tibble() %&gt;% dplyr::filter(stringr::str_detect(value, &quot;Pillow|PyAutoGUI&quot;)) ## # A tibble: 2 × 1 ## value ## &lt;chr&gt; ## 1 Pillow 9.5.0 ## 2 PyAutoGUI 0.9.53 ところで，2つ前のコードのところで，“[notice]”としてpipの最新版がある． これは，pipをバージョンアップしてはどうかという提案である． せっかくなので，バージョンアップしておこう． res &lt;- system(&quot;python.exe -m pip install --upgrade pip&quot;, intern = TRUE) res ## [1] &quot;Requirement already satisfied: pip in c:\\\\users\\\\username\\\\appdata\\\\local\\\\programs\\\\python\\\\python~1\\\\lib\\\\site-packages (22.3.1)&quot; ## [2] &quot;Collecting pip&quot; ## [3] &quot; Using cached pip-23.1.2-py3-none-any.whl (2.1 MB)&quot; ## [4] &quot;Installing collected packages: pip&quot; ## [5] &quot; Attempting uninstall: pip&quot; ## [6] &quot; Found existing installation: pip 22.3.1&quot; ## [7] &quot; Uninstalling pip-22.3.1:&quot; ## [8] &quot; Successfully uninstalled pip-22.3.1&quot; ## [9] &quot; WARNING: The scripts pip.exe, pip3.11.exe and pip3.exe are installed in &#39;C:\\\\Users\\\\username\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\PYTHON~1\\\\Scripts&#39; which is not on PATH.&quot; ## [10] &quot; Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.&quot; ## [11] &quot;Successfully installed pip-23.1.2&quot; 最後に”Successfully installed pip-23.1.2”のような表記があれば，バージョンアップ成功である． これでPythonおよびライブラリPillowとPyAutoGUIのインストールさらにpipのバージョンアップが完了した． 10.3 Windowsでのアプリ・ディレクトリの瞬間起動 {#run_in a_second} ここでは，Windowsでの便利な機能を紹介する． Pathの通ったところにショートカットを保存し，アプリやディレクトリを一発で起動できるというものである． これは非常に便利な機能である． デスクトップが多くのアプリのショートカットがあったり，スタートメニューからアプリを探す人にはぜひ使ってほしい． これを覚えておくだけでもかなりの時間が節約できるだろう． ショートカットをパスの通ったディレクトリに保存 [Win] + [R] で「ファイル名を指定して実行」を起動 ショートカットの名称を入力して[Enter] アプリやディレクトリが起動する なお，MacでもLinuxでもパスの通ったところにあるファイルやディレクトリであれば，シェルから起動できる． Windowsの「ファイル名を指定して実行」の代わりとして，MacはSpotlight([Command] + [Space])が使える． 例えば，RStudioのショートカットをパスの通った”C:“(システムファイルがあるので，パスが通っているはず)に”rst”という名前で保存すると(管理者権限が必要)，[Win] + [R]に続けて”rst”と入力するとRStudioを起動できる． 他のディレクトリにショートカットを保存する場合は，そのディレクトリにパスを通しておく． 上記のショートカットの作成やパスを通す作業はそれぞれ1回だけなのでマウスでの手作業でも全く問題ない． でもせっかくなので，ここではRからショートカットを作成する． もともとパスの通っている”C:“にショートカットを作っても良いのだが，管理者権限が必要なためRからの操作が難しい． そこで，”C:“(USERNAMEは環境によって異なる)というディレクトリを作成し，ここにショートカットを保存するとともに，パスを通すことにする． 以下のコードでは，shell()を利用したautomaterの関数で，RStudioとRのショートカットを作成するとともに，ショートカットを作成したディレクトリにパスを通している． # RStudioのショートカット作成 # 実際のパスと異なる場合は変更する exe &lt;- fs::path(&quot;C:/Program Files/RStudio/rstudio.exe&quot;) shortcut &lt;- &quot;rst&quot; wd &lt;- Sys.getenv(&quot;R_USER&quot;) size = 3 res &lt;- automater::make_shortcut(exe, shortcut = shortcut, size = size, wd = wd) # Rのショートカット作成 # 実際のパスと異なる場合は変更する exe &lt;- fs::path(Sys.getenv(&quot;R_HOME&quot;), &quot;bin/x64/Rgui.exe&quot;) shortcut &lt;- &quot;r&quot; # --no-restore：環境を復元しない，--no-save：終了時に保存しない # --sdi：SDIで起動，--silent：起動時メッセージを出さない arg &lt;- &quot;--no-restore --no-save --sdi --silent&quot; wd &lt;- Sys.getenv(&quot;R_USER&quot;) size = 3 res &lt;- automater::make_shortcut(exe, shortcut = shortcut, arg = arg, size = size, wd = wd) # ショートカットを作成したディレクトリにパスを通す new_path &lt;- fs::path_dir(res$shortcut) %&gt;% automater::add_path() これで，[Win] + [R]で出てきた「ファイル名を指定して実行」に”rst”を入力すればRStudio，“r”を入力すればRが起動する． なお，automater::make_shortcutとautomater::add_pathの中身は以下のとおりである． 独自で関数を作成する際の参考になれば幸いである． automater::make_shortcut ## function (exe, shortcut = NULL, dir = NULL, arg = NULL, size = 1, ## wd = NULL) ## { ## exe &lt;- double_quote(exe) ## if (is.null(dir)) { ## dir &lt;- fs::path(Sys.getenv(&quot;USERPROFILE&quot;), &quot;shortcut&quot;) ## if (!fs::dir_exists(dir)) { ## fs::dir_create(dir) ## } ## } ## else { ## if (!fs::dir_exists(dir)) { ## stop(&quot;directory &quot;, dir, &quot; not found!&quot;) ## } ## } ## if (is.null(shortcut)) { ## shortcut &lt;- fs::path_file(exe) ## } ## shortcut &lt;- fs::path(dir, shortcut) %&gt;% fs::path_ext_set(&quot;lnk&quot;) %&gt;% ## double_quote() ## wsh &lt;- paste0(&quot;$WsShell = New-Object -ComObject WScript.Shell;&quot;) ## create &lt;- paste0(&quot;$Shortcut = $WsShell.CreateShortcut(&quot;, ## shortcut, &quot;);&quot;) ## target &lt;- paste0(&quot;$Shortcut.TargetPath = &quot;, exe, &quot;;&quot;) ## icon &lt;- paste0(&quot;$Shortcut.IconLocation = &quot;, exe, &quot;;&quot;) ## size &lt;- paste0(&quot;$ShortCut.WindowStyle = &quot;, size, &quot;;&quot;) ## if (!is.null(arg)) { ## arg &lt;- double_quote(arg) ## arg &lt;- paste0(&quot;$ShortCut.Arguments = &quot;, arg, &quot;;&quot;) ## } ## if (!is.null(wd)) { ## wd &lt;- double_quote(wd) ## wd &lt;- paste0(&quot;$ShortCut.WorkingDirectory = &quot;, wd, &quot;;&quot;) ## } ## finish &lt;- &quot;$Shortcut.Save()&quot; ## input &lt;- paste0(wsh, create, target, icon, size, arg, wd, ## finish) ## cmd &lt;- &quot;powershell&quot; ## res &lt;- shell(cmd, input = input, intern = TRUE) ## return(list(shortcut = shortcut, res = res)) ## } ## &lt;bytecode: 0x000001a7d20fe9b8&gt; ## &lt;environment: namespace:automater&gt; automater::add_path ## function (new_path) ## { ## if (!fs::dir_exists(dir)) { ## stop(&quot;path &quot;, new_path, &quot; not found!&quot;) ## } ## cmd &lt;- &quot;reg query \\&quot;HKEY_CURRENT_USER\\\\Environment\\&quot; /v \\&quot;path\\&quot;&quot; ## path &lt;- shell(cmd, intern = TRUE)[3] %&gt;% stringr::str_replace(&quot; *path *REG_[A-z]* *&quot;, ## &quot;&quot;) %&gt;% double_quote() ## cmd &lt;- paste0(&quot;setx path &quot;, normalizePath(new_path), &quot;;&quot;, ## path) ## shell(cmd, intern = TRUE) ## } ## &lt;bytecode: 0x000001a7d217ce58&gt; ## &lt;environment: namespace:automater&gt; "],["reticulate.html", "Chap. 11 reticulateでPythonを使う 11.1 準備 11.2 Pythonを使ってみる 11.3 PythoとRとの変数のやり取り 11.4 Pythonのコードを実行 11.5 RとPythoでの用語の違い", " Chap. 11 reticulateでPythonを使う RとPythonのパッケージは，相互に移植されていることが多い． 例えば，Pythonのlogging(とRのfutile.logger)をもとにRのパッケージloggerは開発されている． https://cran.r-project.org/web/packages/logger/index.html また，Rのggplot2やdplyrはPythonにも移植されている． ただし，どちらか片方でしか利用できなかったり，使用方法が難しいことがある． そんなとき，ちょっとだけ使うのであれば，Rのパッケージreticulateが便利である． もちろん，Pythonをちゃんと勉強するのも良いだろう． さらに，reticulateを使うとRとPythonとの変数のやり取りが簡単にできるので，本格的にPythonを使うのにも良さそう． 11.1 準備 install.packages(&quot;reticulate&quot;) library(tidyverse) library(reticulate) library(automater) 11.1.1 PythonとPyAutoGUIのインストール Pythonとそのライブラリのインストールを参照して，PythonとPyAutoGUIをインストールしておく． ライブラリの一覧の中に，あとで使うnumpy，matplotlib，artがなければインストールしておく． なお，この文書ではPythonをパッケージ版でインストールしするとともに，pipでパッケージを管理している． Anacondaやminicondaで仮想環境を使用している場合は，retuculate::conda_install()でパッケージをインストールする． system(&quot;pip list&quot;, intern = TRUE) %&gt;% tibble::as_tibble() %&gt;% dplyr::filter(stringr::str_detect(value, &quot;numpy|matplotlib|art&quot;)) ## A tibble: 0 × 1 ## ℹ 1 variable: value &lt;chr&gt; 一覧に”numpy”，“matplotlib”，“art”などのライブラリ名がなければ，以下のコードでライブラリをインストールする． system(&quot;pip install numpy&quot;, intern = TRUE) system(&quot;pip install matplotlib&quot;, intern = TRUE) system(&quot;pip install art&quot;, intern = TRUE) ライブラリがインストールできたか念のため確認したい場合は，以下のようにする． system(&quot;pip list&quot;, intern = TRUE) %&gt;% tibble::as_tibble() %&gt;% dplyr::filter(stringr::str_detect(value, &quot;numpy|matplotlib|art&quot;)) ## # A tibble: 3 × 1 ## value ## &lt;chr&gt; ## 1 art 5.9 ## 2 matplotlib 3.7.1 ## 3 numpy 1.24.2 11.1.2 使用するPythonの指定 1つのパソコンにバージョンや形態の異なるPythonを複数インストールすることが可能である． Pythonとそのライブラリのインストールで説明したようなPythonパッケージのインストーラを用いたもの(パッケージ版Python)もあれば，Microsoft Store版のPythonもある． さらに，Anacondaをインストールしてその中でPythonを使うこともできる． 色々とあってややこしいが，この文章ではパッケージ版Pythonを使うことにする． reticulateで使用するPythonとしてインストールしたパッケージ版Pythonを指定する． なお，AnacondaなどにあるPythonを使う場合は，別途インストールして，use_condaenv()で指定する． ここでは，パッケージ版Pythonを使用する． Pythonのパスが分かってれば，use_python()でそのパスを指定する． パスが分からなければ，以下のようにfind_python()を使うことができる． Pythonが1つだけのときは，パスがそのまま取得できる． 複数のPythonがインストールされている場合は，メニューが表示される． 例えば，以下のような文字列が入っている可能性がある． C:/Users/your_user_name/AppData/Local/r-miniconda/envs/r-reticulate/python.exe C:/Users/your_user_name/AppData/Local/Microsoft/WindowsApps/python.exe メニューが表示されれば，使用するPythonのパスの番号を入力する． どれを使っていいのかわからない場合は，“0”でとりあえず全部のパスを出力する． その後，それぞれのパスのPythonがどのようなものか確認してからどれを使うか決める． なお，Windowsでパスに”WindowsApps/python.exe”があるときは，このファイルはアプリ実行エイリアスという機能でPythonをインストールための実行ファイルである． 以下を参考にアプリ実行エイリアスの設定でチェックを外すとパスの一覧からは出なくなる． 参考：https://hrkworks.com/it/programming/python/py-4421/ find_python &lt;- function(select_memu = TRUE){ os &lt;- get_os() python_path &lt;- ifelse(os == &quot;win&quot;, &quot;where python&quot;, &quot;which python&quot;) %&gt;% system(intern = TRUE) %&gt;% fs::path() if(length(python_path) &gt; 1){ if(select_memu){ choice &lt;- utils::menu(python_path, title = &quot;Select Python path. 0: exit and return all.&quot;) if(choice == 0){ return(python_path) } }else{ return(python_path) } }else{ choice &lt;- 1 } return(python_path[choice]) } path &lt;- find_python() path ## C:/Users/matu/AppData/Local/Programs/Python/Python311/python.exe reticulate::use_python(path) 11.2 Pythonを使ってみる 11.2.1 Pythonの呼び出し repl_python()を実行するとRからPythonを呼び出すことができる． Python実行時にはコンソールが&gt;から&gt;&gt;&gt;に変化する． 古典的なことだが，まずはHellow World!を実行する． “Hellow World!”が出力されたら成功である． コンソールが&gt;&gt;&gt;のときにexitかquitとすればRに戻る． repl_python() ## Python 3.11.1 (C:/Users/username/AppData/Local/Programs/Python/Python311/python.exe) ## Reticulate 1.28 REPL -- A Python interpreter in R. ## Enter &#39;exit&#39; or &#39;quit&#39; to exit the REPL and return to R. &gt;&gt;&gt; print(&quot;Hello World!&quot;) ## Hellow World! &gt;&gt;&gt; exit 他にもPythonで実行したいことがあれば，&gt;&gt;&gt;のときに入力する． 11.2.2 RからPythonのHellow World! Pythonにあらかじめ用意されているビルトイン関数を使うには，import_builtins()を使う． import_builtins()で生成したオブジェクトに$とPythonの関数名をつければ，Rの関数として使うことができる． builtins &lt;- reticulate::import_builtins() builtins$print(&#39;Hellow World!&#39;) ふつうにHellow World!をしていても面白くないので，ちょっと変わったHellow World!をしてみる． ライブラリartを呼び出して，Hellow World!をするとちょっと面白い． art &lt;- reticulate::import(&quot;art&quot;) art$tprint(&quot;Hellow World!&quot;) ## _ _ _ _ __ __ _ _ _ ## | | | | ___ | || | ___ __ __ \\ \\ / / ___ _ __ | | __| || | ## | |_| | / _ \\| || | / _ \\ \\ \\ /\\ / / \\ \\ /\\ / / / _ \\ | &#39;__|| | / _` || | ## | _ || __/| || || (_) | \\ V V / \\ V V / | (_) || | | || (_| ||_| ## |_| |_| \\___||_||_| \\___/ \\_/\\_/ \\_/\\_/ \\___/ |_| |_| \\__,_|(_) art$tprint(&quot;FUN&quot;, font = &quot;block&quot;, chr_ignore = TRUE) ## .----------------. .----------------. .-----------------. ## | .--------------. || .--------------. || .--------------. | ## | | _________ | || | _____ _____ | || | ____ _____ | | ## | | |_ ___ | | || ||_ _||_ _|| || ||_ \\|_ _| | | ## | | | |_ \\_| | || | | | | | | || | | \\ | | | | ## | | | _| | || | | &#39; &#39; | | || | | |\\ \\| | | | ## | | _| |_ | || | \\ `--&#39; / | || | _| |_\\ |_ | | ## | | |_____| | || | `.__.&#39; | || ||_____|\\____| | | ## | | | || | | || | | | ## | &#39;--------------&#39; || &#39;--------------&#39; || &#39;--------------&#39; | ## &#39;----------------&#39; &#39;----------------&#39; &#39;----------------&#39; 遊んでばかりいても仕方ないので，ちょっと真面目に使ってみよう． Pythonで，np.random.randと表記するものをRで使うには，np$random$randとする． Rのオブジェクトに代入してしまえば，あとは慣れたもので簡単に散布図が作成できる． np &lt;- reticulate::import(&quot;numpy&quot;) # import numpy as npと同じ x &lt;- np$random$rand(as.integer(100)) y &lt;- np$random$rand(as.integer(100)) tibble::tibble(x, y) %&gt;% ggplot2::ggplot(aes(x, y)) + ggplot2::geom_point() + ggplot2::theme_bw() 11.3 PythoとRとの変数のやり取り 行ったり来たりつつRとPythonを使いたいことがあるかもしれない． つまりrepl_python()を使ってPythonに入って，exitでRでに戻って，またPythonに入るなどである． そのときに，RとPythonの変数のやりとりができる． PythonでRのvariableという変数を取り出したいときはr.variable，RでPythonのvariableという変数を取り出したいときにはpy$variableとする． r.variable # RからPythonへ(Pythonで取り出し)，variableは変数名 py$variable # PythonからRへ(Rで取り出し) これでRとPythonを対話的に行きつ戻りつしながら実行できる． a &lt;- &quot;r_val&quot; repl_python(quiet = TRUE) &gt;&gt;&gt;r.a ## &#39;r_val&#39; &gt;&gt;&gt;a = &quot;python_val&quot; &gt;&gt;&gt;exit py$a ## [1] &quot;python_val&quot; 11.4 Pythonのコードを実行 既にPythonの関数やコードのファイルがある場合は，source_python()でファイルを読み込んで使うことができる． reticulate::source_python() source_python()でのコード内の関数や変数をそのままRで使うことができる． reticulate::py_run_file(&quot;script.py&quot;) reticulate::py_run_string(&quot;x = 10&quot;) py_run_file()やpy_run_string()でのコード内の変数や関数をRで使う場合は，py$valのようにpy$の後ろに変数や関数の名前を付ける必要がある． 11.5 RとPythoでの用語の違い Pythonでのモジュールとはファイル(*.py)のことで，モジュールをまとめたものがパッケージ，パッケージをまとめたものがライブラリである． このライブラリをpip installでインストール，import()でインポートしている． つまり，Rでのパッケージにあたるのが，Pythonでのライブラリである． # USB取り出し用の画像のトリミング(作業済) # トリミングをしたほうが画像認識がうまくいくかとおもったが，逆にダメだった # library(tidyverse) # path &lt;- # &quot;D:/matu/work/ToDo/automater/inst/img&quot; %&gt;% # fs::dir_ls(regexp = &quot;png&quot;) # img &lt;- # path %&gt;% # purrr::map(magick::image_read) %&gt;% # purrr::map(magick::image_trim) # purrr::map2(img, path, magick::image_write) # path # 画面サイズの取得だが，実際は拡大をしていたりするので，ちょっと数字が違う # system(&quot;wmic path Win32_VideoController get VideoModeDescription,CurrentVerticalResolution,CurrentHorizontalResolution /format:value&quot;) "],["keyboardsimulator.html", "Chap. 12 KeyboardSimulatorでマウス・キーボードの自動化 12.1 準備 12.2 マウスの移動 12.3 マウスの位置取得 12.4 USBメモリの安全な取り出しの自動化 12.5 画像をもとにマウスを動かしてクリックする 12.6 (コラム)画面サイズ取得の試行錯誤", " Chap. 12 KeyboardSimulatorでマウス・キーボードの自動化 KeyboardSimulatorを使うと，Rから直接操作しづらいくても，マウスやキーボードを用いて決まった操作をするものは自動化可能である． ただし，このパッケージはWindows専用である． 12.1 準備 キーボードとマウスの自動操作のパッケージKeyboardSimulatorをインストールする． install.packages(&quot;KeyboardSimulator&quot;) library(tidyverse) library(KeyboardSimulator) library(automater) # mouse.get_cursor() KeyboardSimulatorでは，マウスやキーボードの操作とマウス位置の取得は可能であるものの，アイコンの画像をもとに画面上での位置の取得ができない． 画像からの位置取得のために，PythonとそのライブラリPillowとPyAutoGUIを使用する． これらのインストールがまだの場合は，[Pythonとそのライブラリのインストール](#install_python}を参考にして，Python，Pillow，PyAutoGUIをインストールする． また，RからPythonを使うためにreticulateを呼び出しておく． library(reticulate) さらに，使用するPythonの指定を参考にreticulateで使用するPythonを指定する． automaterパッケージのfind_python()を使用すると，楽に指定ができる． インストール済のPythonを探して1つだけのときはそのパスを出力する． 複数ある場合は選択肢からユーザが選んだパスが出力される．． find_pythonの中身は以下のとおりである． find_python &lt;- function(select_memu = TRUE){ os &lt;- get_os() python_path &lt;- ifelse(os == &quot;win&quot;, &quot;where python&quot;, &quot;which python&quot;) %&gt;% system(intern = TRUE) %&gt;% fs::path() if(length(python_path) &gt; 1){ if(select_memu){ choice &lt;- utils::menu(python_path, title = &quot;Select Python path. 0: exit and return all.&quot;) if(choice == 0){ return(python_path) } }else{ return(python_path) } }else{ choice &lt;- 1 } return(python_path[choice]) } もちろん，自分でPythonのパスを指定しても良い． reticulate::use_python(&quot;your_python_path&quot;) 12.2 マウスの移動 マウスの移動は次のようにする． コードを実行すると移動の様子を実際にみることができる． KeyboardSimulator::mouse.move(10, 10, duration = 1, step_ratio = 0.1) KeyboardSimulator::mouse.move(100, 100, duration = 0.5) 12.3 マウスの位置取得 マウス操作で重要なのは画面上での位置を取得することである． KeyboardSimulatorには，マウス位置を取得する関数mouse.get_cursor()がある． 1箇所だけならこの関数で十分だが，何度かマウスをクリックする作業の場合は何度も実行する必要があってちょっとめんどくさい． KeyboardSimulator::mouse.get_cursor() ## [1] -3297 1306 以下で作成するUSBの取り外しの関数では，タスクバーとRウインドウとの行き来をしていると，タスクバーの操作がもとに戻ってしまうことがあり，正しいマウスの位置を取得するのが難しいことがある． そこで，一定時間の間隔でマウス位置を取得するautomaterの関数を利用する． 関数の内容は以下のとおりである． automater::mouse_record ## function (n = 5, interval = 1) ## { ## x &lt;- list() ## y &lt;- list() ## for (i in seq(n)) { ## if (interval &lt; 0) { ## user_input(&quot;Press any keys on R console&quot;) ## } ## else { ## automater::sleep(interval) ## } ## x[[i]] &lt;- KeyboardSimulator::mouse.get_cursor()[1] ## y[[i]] &lt;- KeyboardSimulator::mouse.get_cursor()[2] ## position &lt;- paste0(i, &quot;: x = &quot;, x[[i]], &quot;, y = &quot;, y[[i]], ## &quot;\\n&quot;) ## cat(position) ## } ## return(list(x = unlist(x), y = unlist(y))) ## } ## &lt;bytecode: 0x000002ad4a634de0&gt; ## &lt;environment: namespace:automater&gt; sleep()を挟んで，n回分の位置を取得するだけの関数である． 実行すると以下のような結果が得られる． 位置を表示させているのが煩わしければ，ループ中の最後の2行を削除すれば良い． position &lt;- automater::mouse_record() position ## 1: x = 680, y = 587 ## 2: x = 162, y = 482 ## 3: x = 94, y = 1250 ## 4: x = 816, y = 1352 ## 5: x = 773, y = 511 ## $x ## [1] 680 162 94 816 773 ## ## $y ## [1] 587 482 1250 1352 511 12.4 USBメモリの安全な取り出しの自動化 ここでは「USBの安全な取り出し」を自動化する． タスクバーにあるUSBのアイコンを何度かクリックして，USBを安全に取り出せるようにするものである． この作業をしなくても，USBディスクが壊れることはほとんど無いだろうが，作業するに越したことは無い． 単純な操作だが，何度もやっていると面倒くさいし，しかも老眼の人間には避けたい作業である． マウスをどこでクリックしているのか，あらかじめ位置を取得しておく必要がある． mouse_record()を使えば，マウス位置を簡単に取得できる． position &lt;- automater::mouse_record(n = 4, interval = -1) position ## $x ## [1] 770 730 700 1040 ## $y ## [1] 1900 1800 1760 1750 USBメモリの安全な取り出しをする前の位置にマウスを戻したい場合は，あらかじめposに代入しておき，最後にその位置に戻す． あとは，上で取得した位置にマウスを移動させ，順次クリックしていくだけだ． 実際にUSBメモリをパソコンに取り付けて，動作を確認する必要がある． マウスの移動速度が早すぎて，パソコンの動作よりも先にクリックをしてしまう場合があるかもしれない． その場合は，sleep_sec = 1(デフォルトは0.5秒)などと調整の必要がある． pos &lt;- KeyboardSimulator::mouse.get_cursor() automater::mouse_move_click( 770,1900) automater::mouse_move_click( 730,1800) automater::mouse_move_click( 700,1760) automater::mouse_move_click(1040,1750) automater::mouse_move_click(pos[1], pos[2]) また，アプリ・ディレクトリの瞬間起動を参考に，以下のようにすれば，瞬間起動ができる． 上記の内容をテキストファイルremove_usb.rscとして保存 remove_usb.rscをクリックして，USBメモリの安全な取り出しを実行 さらに，パスの通ったディレクトリにショートカットをruとして保存 [Win] + [R]の「ファイル名を指定して実行」にruと入力 remove_usb.rscが実行されてUSBメモリの安全な取り出しが起動 12.5 画像をもとにマウスを動かしてクリックする アイコンの位置が固定されている，つまりマウスのクリック位置が一定であれば，automater::mouse_move_click(1040,1750)のような定位置で良い． しかし，ウィンドウの位置が異なったり，タスクバー上での位置が変化したりして，クリックするべき位置が一定でないことがある． クリックする対象を画像ファイルとして用意できれば，その画像をもとにクリックの位置を決定できる． Rのパッケージではこれを実現できなさそうなので，PythonのPyAutoGUIを利用する． Pythonに慣れていない筆者は何度かコケてしまったのが，Pythonでライブラリが大文字を含んでいても，呼び出すときは小文字で指定しないといけないようだ． # reticulate::use_python(&quot;your_python_path&quot;) # reticulate::use_python(automater::find_python()) pag &lt;- reticulate::import(&quot;pyautogui&quot;) # 呼び出し時は小文字で 以下ではディスプレイの左下部部のスクリーンショットをとって，一時フォルダにpng保存する． スクリーンショットの範囲は，ディスプレイの左下の100*100ピクセルである． この範囲をpngとして保存する． region &lt;- automater::display_corner(corner = &quot;bottom_left&quot;, width = 100, height = 100) screenshot &lt;- pag$screenshot(region = region) # ls(&quot;package:fs&quot;) png &lt;- fs::path_temp(&quot;screenshot.png&quot;) screenshot$save(png) pag$locateOnScreen()は画像のパスを指定して，その画像の位置を得ることができる． 位置は，画像の4つの頂点の位置なので，その中心をautomater::center()で取得し，その位置へマウスを移動する． ここではマウスの移動はpag$moveTo()でしているが，もちろんKeyboardSimulator::mouse.move()でも構わない． コードを実行して画像が正しく認識されると，正しい位置(左下から左に50・上に50の位置)に移動するはずである． マウスが動かない場合は，画像認識がうまくいっていない可能性が高い． PyAutoGUIの画像認識は，ディープラーニングのような似たものを抽出するのではなく，ピクセル単位で合致するもの，つまり全く同じ画像を探し出すものである． そのため，取得したスクリーンショットの状態から変化があると認識できない． これを改善するためには，pag$locateOnScreen()でconfidence = 0.6のように画像認識の精度を設定する． 完全に一致しなくても結果を返してくれるが，下げすぎると誤認識の可能性が出てくる． また，confidenceを使うには，PythonのライブラリであるOpenCV-Pythonをインストールしなければならない． shell(&quot;pip install opencv-python&quot;) さらに，grayscale = TRUEを指定すると白黒画像として認識するため若干であるが高速化する． # img &lt;- fs::path_package(&quot;automater&quot;, &quot;img/up_arrow.png&quot;) position &lt;- pag$locateOnScreen(png) position &lt;- automater::center(position) pag$moveTo(position$x, position$y) # durationの指定が可能 pag$moveTo(10,10, duration = 5) 画像から位置を取得するとき，画面全体を検索すると時間がかかる． 設定によるが，USBメモリの取り出しやwifiへの接続なら画面の右下，スタートメニューなら画面の中央か左下のように，ある程度の位置が決まっているので，その領域のみ検索すれば動作が早くなる． そこで，検索する領域を画面サイズから位置を指定する． パソコンの設定を見て手入力しても良いが，できれば自動的に取得したい． 画面サイズを取得するには，display_size()を使いう． 画面の4隅の位置を指定するには，display_size()を含んでいるdisplay_corner()を使う． 関数の実行例と中身は以下を見てほしい． automater::display_size() automater::display_size automater::display_corner() automater::display_corner これまでの内容を踏また画像から位置をクリックする関数としてrecog_image_click()がある． 以下の引数が利用可能である． wait：TRUEでは，画像が見つかるまで画像認識を1秒間隔で繰り返す．パソコン描画がマウスの自動化に追いつかないときには便利． button：クリックの左右を指定．c(“left”, “right”) hold：クリックの保持を指定．TRUE, FALSE …：オプションの引数でpag$locateOnScreen()に渡される region：画像の検索範囲を指定．display_corner()で指定可能 grayscale：TRUEで白黒認識 confidence：認識精度を数値で指定(0-1) 使い方と関数の内容は以下を見てほしい． region &lt;- automater::display_corner() img &lt;- &quot;your_image_path&quot; automater::recog_image_click(img, pag, region = region) automater::recog_image_click 画像をもとにしてマウスを動かすことができれば，定位置での操作だけでなく，まるで人間が作業しているようなこともできる． 繰り返しだが，画像が完全に一致しないときには認識できないことがあるので，grayscaleやconfidenceでうまく調整しなければならない． また，描画が追いつかないときへの対応も必要である． 12.6 (コラム)画面サイズ取得の試行錯誤 本文では，画面サイズの取得方法する関数display_size()をさらっと紹介したが，関数完成には試行錯誤があった． スマートな解決方法をすぐに思い付けば良いのだが，なかなかそうは行かない． まず試したのは，rJavaを使う方法である． rJavaで画面サイズの取得は可能であるが，あまりおすすめしない． 「おすすめしない」というのは理由がある． rJavaパッケージはその名のとおりRからJavaを利用するものだが，うまく動作しないことがあるからだ． 通常のパッケージならインストールして呼び出せば，そのまますぐに使えるはずだが，rJavaはうまくいかないことがある． OSにインストールされているJavaのバージョンとRとの関係や，パスの設定の関係でエラーが出て動かないことがある． うまくいくか分からないが，次のコードが動けば使って画面サイズを取得できる． # C:\\Users\\matu&gt;java -version # java version &quot;1.8.0_361&quot; # Java(TM) SE Runtime Environment (build 1.8.0_361-b09) # Java HotSpot(TM) 64-Bit Server VM (build 25.361-b09, mixed mode) # C:\\Users\\matu&gt;path # PATH=C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;C:\\Program Files (x86)\\Java\\jre1.8.0_361\\bin\\client # ユーザの環境変数 # C:\\Program Files (x86)\\Java\\jre1.8.0_361\\bin\\client install.packages(&quot;rJava&quot;) library(rJava) .jinit() toolkit &lt;- J(&quot;java.awt.Toolkit&quot;) default_toolkit &lt;- .jrcall(toolkit, &quot;getDefaultToolkit&quot;) dim &lt;- .jrcall(default_toolkit, &quot;getScreenSize&quot;) width &lt;- .jcall(dim, &quot;D&quot;, &quot;getWidth&quot;) height &lt;- .jcall(dim, &quot;D&quot;, &quot;getHeight&quot;) いくつかの環境で試したが，どうも設定がよくわからない場合があった． rJavaがあまり良くなさそうなので，別の方法を考えた． Windowsであれば，次のコードのようにsystem()を使ってコマンドを入力して情報を得ることができる． ただし，この場合は注意が必要で，ここで取得したのは画面の解像度であって，KeyboardSimulatorで指定するマウスの位置ではないことがある． 高解像度の画面の場合は，画面を125%に拡大していることがあるためだ. その場合は，ここで得た値を1.25で割る必要がある． # https://stackoverflow.com/questions/7305244/how-can-i-get-the-screen-resolution-in-r library(tidyverse) # cmd &lt;- &quot;wmic path Win32_VideoController get CurrentHorizontalResolution,CurrentVerticalResolution /format:value&quot; item &lt;- c(&quot;CurrentHorizontalResolution&quot;, &quot;CurrentVerticalResolution&quot;) cmd &lt;- paste0(&quot;wmic path Win32_VideoController get &quot;, item, &quot; /format:value&quot;) resol &lt;- cmd %&gt;% purrr::map(system, intern = TRUE) %&gt;% purrr::map(paste0, collapse = &quot;&quot;) %&gt;% purrr::map_chr(stringr::str_replace_all, &quot;[A-z\\\\r=]+&quot;, &quot;&quot;) %&gt;% as.double() rJavaもダメで，system()を使っても注意が必要であり，自動化もいろいろと大変である． 自動化すれば手を抜けるが，手を抜くための努力は必要だ． 著者も色々と試行錯誤したが，結局たどり着いたのは簡単な方法であった． 次のようにmouse.move()でマウスをありえないぐらい右下に移動して，その位置を取得する方法だ． 幸いなことに，mouse.move()はありえない位置を指定してもエラーにはならず，最大限可能なところまで移動してくれる． 最大限に移動した位置を取得すれば完了だ． 画面の最大値とマウスの位置が1つずれているのは，画面の左上が[1,1]ではなく[0,0]のためだ． KeyboardSimulator::mouse.move(999999,999999) KeyboardSimulator::mouse.get_cursor() 以上のように，関数を1つ作るにも試行錯誤をともなうことがある． もちろん，考えた関数がそのままうまく動けばよいが，そうでないときも多い． 出来上がった関数だけを見れば非常にスマートな解決方法を実装していても，その背景には多くの試行錯誤や失敗(成功の糧)があるのであった． "],["ggplot2.html", "Chap. 13 ggplot2で楽に綺麗に作図 13.1 準備 13.2 Rの作図環境の概要 13.3 ggplot2とは 13.4 ggplot2の基本 13.5 facetで簡単に分割作図 13.6 ggsave 13.7 文字化けへの対処(windows) 13.8 themeを少しだけ説明 13.9 作図の自動化 13.10 参考書", " Chap. 13 ggplot2で楽に綺麗に作図 13.1 準備 library(tidyverse) library(ggplot2) 13.2 Rの作図環境の概要 Rの作図環境として主なものは以下の4つがある． base graphics lattice grid ggplot2 base graphicsは古典的な作図環境で長らく使われてきた． Rが統計解析のシステムとして使われるようになった理由の1つとして強力な作図環境があり，まさしくこのbase graphicsシステムがそれに当たる． すごく便利なものと当時は考えていた． ただし，base graphicsは紙と鉛筆を使って作図していくようなものだと喩えられることがあるように，作図済みのものは修正できない． また，作図する関数によって引数の取り方が異なるなど，発展するなかで継ぎ接ぎだらけになってしまった． システムが急速に発展する中ではこのような状況はよくあり，途中から綺麗に整理し直すことは困難である． 新しいシステムを作り直す方が楽であり現実的である． そのような状況もあってか，lattice，それをもとにしたgrid，さらにはこの2つをベースにしたggpot2が開発された． これら3つの作図環境のうち，最近ではggplot2が最も使われているものである． ggplot2では，Grammar of Graphics，つまり作図の文法という考え方が用いられており，洗練された作図が可能である． 詳細は「ggplot2」(Hadley )を参照して欲しい． 13.3 ggplot2とは ggplot2は，作図環境を提供するパッケージである． 統一的なインターフェスを持っており，非常に使いやすい． 散布図を作成したデータをもとにして，簡単に箱ひげ図などの他の形式の作図やグループ分けした作図も簡単である． 13.3.1 ggplot2の利点 ggplot2では，第1引数としてtidyなデータフレームを受け取る． 1つのデータから各種作図が可能 ちょっとの変更で棒グラフ，散布図など各種の作図が可能 図が綺麗 テーマの変更が簡単 facetによるグループ分けが便利 magrittrによるパイプとの相性が良い 特にファイル名を設定するときの%$%や%T%など ggplot2をサポートするパッケージも豊富 凡例の自動的な位置決めや配置など ggpubrなども 13.4 ggplot2の基本 aesthetics geom_point() geom_bar() aes() colour group size 13.5 facetで簡単に分割作図 facetは，もともとは宝石をカットしたときの面を指すことばのようだが，ggplot2においては全体のデータを分割して表示させることを意味する． つまり，1つのデータを色々な側面から分析しようという意図でfacetが使われている． 例えば，irisのデータを全種でプロットするのではなく，種ごとに作図するのがfacetである． ggplot2ではこれが簡単にできて，しかも作図したものが見やすく，色々と指定できる点でも優れている． forループやsubset，あるいはdplyr::filterを使っていたものが，一気にできて便利 コードも簡単で見やすい コードの転用が簡単 group VS facet 13.6 ggsave pngとPDF PDFで日本語文字が化ける場合は，pngを使う 指定しないと，直前のプロット 13.7 文字化けへの対処(windows) -cario? 13.8 themeを少しだけ説明 デフォルト theme_bw() 13.9 作図の自動化 例を示す． 入力：readr, readxl エクセルかcsvでデータ入力 分析：dplyr, stringr filter(), summarise(), tally() 作図：ggplot2 ggplot() geom_point() geom_jitter() geom_boxplot() ggsave() 13.10 参考書 ggplot2 ggplot2のレシピ unwin GDA チートシート "],["rvest.html", "Chap. 14 rvestでスクレイピング 14.1 スクレイピング 14.2 rvest と RSelenium 14.3 rvestのできること 14.4 準備 14.5 HTMLの取得 14.6 必要な情報の取得 14.7 URLの生成・データの取得 14.8 地図画像の取得 14.9 複数種への対応 14.10 おまけ：webshotでウエブページを画像に変換", " Chap. 14 rvestでスクレイピング 14.1 スクレイピング スクレイピングとは，ウェブスクレイピングの省略のことで，ウェブサイトにある情報を収集することである． ウェブサイトから植生調査データを収集することは少ないものの，関連データの収集は可能である． 例えば，気象庁のページから気象データが収集可能である． 手動でも可能だが多大な手間と時間が必要で，研究に必要なデータを自動で取得できれば，手間と時間の節約が可能である． ここではウェブでの情報収集の方法を紹介する． 具体的には気象庁のページから世界各地の気象データを入手する． 情報収集にはRのパッケージであるrvestを用いる． 14.2 rvest と RSelenium スクレイピングをするために使われる主なRのパッケージとしては，rvestとRSeleniumがある． rvestは，静的なサイトを対象とするときに役立つ． つまり，URLを指定すれば対象のサイトのページが決まるときである． 気象庁での気象データを提供しているページがこれに当たる． 一方，RSeleniumは動的なサイトを対象とするときに役立つ． 例えば，テキストボックスへのデータ入力やプルダウンメニューの選択あるいはその後のマウス操作でページが遷移する場合だ． このような動的なサイトでは，Seleniumだけでなく，Javascriptを部分的に用いるのも効果的である． なお，rvestでもユーザ名とパスワードを用いた一般的なログインは可能で，politeパッケージと組み合わせることである程度の動的なサイトのスクレイピングは可能である． 14.3 rvestのできること HTMLの取得 DOMの取得: id, class, tagNameなどを用いる tableの取得 HTML内の取得したいデータはtableにあることが多いため，非常に便利 そもそも，tableでないデータを取得するのは非常に不便 リンクの取得 ページ遷移に使用する stringrと組み合わせて使うと良い 文字コードの変換にはstringiを用いる tidyverseやmagrittrとの合せ技が便利 Formの入力・選択 radioボタンはちょっと工夫が必要 -moranajp::html_radio_set() 無理やりな感じではあるが，同一名称のradioボタンを全て同じ値に変更する 本来なら，不要なradioボタンのフォームを削除 可能だが，インデクスがずれるので結構厄介 politeパッケージとの連携 使えば便利だが，ここでは説明せず 14.4 準備 例によってrvestをインストールする． curlとpoliteパッケージは少しだけ使うので予めインストールしておく． tidyverseは既にインストールしているはずだが，まだの場合はインストールする． install.packages(&quot;rvest&quot;) install.packages(&quot;curl&quot;) install.packages(&quot;polite&quot;) # install.packages(&quot;moranajp&quot;) # install.packages(&quot;tidyverse&quot;) # 未インストールの場合 library(rvest) library(tidyverse) 14.5 HTMLの取得 スクレイピングによってデータを取得するには，取得したいページのURLを特定しなければならない． 静的なページのURLであれば，ブラウザのアドレスバーにあるURLをそのまま使えば良い． 動的あるいは特定の規則に従ったURLであれば，取得したいページのURLの規則性を知らなければならない． ここでは，「日本のレッドデータ検索システム」から都道府県のRDB指定状況とその地図情報の画像を入手することを考える． http://jpnrdb.com/search.php?mode=spec まずはブラウザでページにアクセス，手作業で検索，指定状況とその地図情報の画像を入手してみる． 上記URLで例として示されているニッコウキスゲをキーワード(種名)として入力すると，ページが遷移する． アドレスバーにはカタカナがそのまま表示されている． しかし，アドレスをコピーしてテキストエディタに貼り付けると文字化けしたようになる． これはURLエンコードによってコード変換された結果であるが安心して欲しい． rvestを使ってHTMLを取得するときには，日本語をそのまま使用することができる． 上記のURLのうち「 http://jpnrdb.com/search.php?mode= 」まではここで使用するページに共通する部分であるため，mainとしておく． 検索したい種名は変更する部分で，とりあえずspに入れておく． キーワード検索の命令(phpによるクエリ)と種名の文字列を結合し，さらにmainと結合する． これで得たURLをread_html()に与えると，ページのHTMLを得ることができる． main &lt;- &quot;http://jpnrdb.com/search.php?mode=&quot; sp &lt;- &quot;ニッコウキスゲ&quot; find_sp &lt;- paste0(&quot;key&amp;q=&quot;, sp) html &lt;- paste0(main, find_sp) %&gt;% rvest::read_html() html ## {html_document} ## &lt;html&gt; ## [1] &lt;body&gt;\\n&lt;em&gt;&lt;/em&gt;\\n\\n&lt;title&gt;日本のレッドデータ検索システム&lt;/title&gt;\\n&lt;meta http-equiv=&quot;co ... ところで，手作業にはなってしまうが，ニッコウキスゲを検索した結果のページをブラウザで表示させ，その後のページの内容を確認する． ウエブページには次の規則性があることに気づく． 検索結果のページには表(table)としてデータが含まれており，その表の中の目録Noである「5259」が指定状況や地図のページのURLに含まれている． つまり，目録Noを入手すれば指定状況や地図ページのURLを生成できそうだ． 14.6 必要な情報の取得 read_html()で取得したHTMLには必要な情報が含まれているが，そのままの状態では使い物にならない． また，文字列に変換してstringrを駆使すれば，情報を得ることはできるだろうが，多大な苦労が待っている． HTMLの全体を表示させたい場合は，以下のコードを実行する． とてもではないが，これを自分で解析したいとは思わないだろう． # 全体を表示させたい場合 as.character(html) %&gt;% cat() 最初と最後の部分だけを示すと次のようになる． as.character(html) %&gt;% stringr::str_split(&quot;\\\\n&quot;) %&gt;% `[[`(1) %&gt;% head() ## [1] &quot;&lt;!DOCTYPE html PUBLIC \\&quot;-//W3C//DTD HTML 4.0 Transitional//EN\\&quot; \\&quot;http://www.w3.org/TR/REC-html40/loose.dtd\\&quot;&gt;&quot; ## [2] &quot;&lt;html&gt;&lt;body&gt;&quot; ## [3] &quot;&lt;em&gt;&lt;/em&gt;&quot; ## [4] &quot;&quot; ## [5] &quot;&lt;title&gt;日本のレッドデータ検索システム&lt;/title&gt;&quot; ## [6] &quot;&lt;meta http-equiv=\\&quot;content-type\\&quot; content=\\&quot;text/html;charset=utf-8\\&quot;&gt;&quot; as.character(html) %&gt;% stringr::str_split(&quot;\\\\n&quot;) %&gt;% `[[`(1) %&gt;% tail() ## [1] &quot;}&quot; &quot;&quot; &quot;//--&gt;&quot; &quot;&lt;/script&gt;&quot; ## [5] &quot;&lt;/body&gt;&lt;/html&gt;&quot; &quot;&quot; 幸いにしてrvestにはhtmlから要素を取得するための便利な関数が用意されている． ウエブページを見ると，tableにデータが入っていそうなので，html_table()でデータを抽出する． ここではスペースの節約のためpurrr::map(colnames)として列名だけ表示するとともに不要なスペースを除去している． なお，rvest::html_table(html)とするとtable全体を表示できる． rvest::html_table(html) %&gt;% purrr::map(colnames) %&gt;% purrr::map(stringr::str_remove, &quot; &quot;) ## [[1]] ## [1] &quot;X1&quot; ## ## [[2]] ## [1] &quot;X1&quot; ## ## [[3]] ## [1] &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; &quot;X5&quot; &quot;X6&quot; ## ## [[4]] ## [1] &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; &quot;X5&quot; &quot;X6&quot; &quot;X7&quot; &quot;X8&quot; &quot;X9&quot; &quot;X10&quot; &quot;X11&quot; &quot;X12&quot; ## ## [[5]] ## [1] &quot;X1&quot; &quot;X2&quot; ## ## [[6]] ## [1] &quot;目録No▲▼&quot; ## [2] &quot;上位分類群▲▼&quot; ## [3] &quot;科名▲▼&quot; ## [4] &quot;和名▲▼／学名\\r\\n\\t\\t ▲▼&quot; ## [5] &quot;指定都道府県数▲▼&quot; ## [6] &quot;環境省▲▼&quot; ## ## [[7]] ## [1] &quot;X1&quot; &quot;X2&quot; ## ## [[8]] ## [1] &quot;X1&quot; &quot;X2&quot; 列名から6個目のtableが目録Noを含んでいそうだと考えられるので，6つ目の表を表示させる． rvest::html_table(html) %&gt;% `[[`(6) ## # A tibble: 2 × 6 ## `目録No▲▼` `上位分類群▲▼` `科名▲▼` 和名▲▼／学名\\r\\n\\t\\t…¹ `指定都道府県数▲▼` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 5266 単子葉類 ユリ ゼンテイカ  Hemerocalli… 6 ## 2 5259 単子葉類 ユリ ニッコウキスゲ  Hemeroc… 3 ## # ℹ abbreviated name: ¹​`和名▲▼／学名\\r\\n\\t\\t ▲▼` ## # ℹ 1 more variable: `環境省▲▼` &lt;chr&gt; 和名としてゼンテイカとニッコウキスゲの2つが示されている． ゼンテイカはニッコウキスゲの別名である． ほぼ同じものなので，本来は両方の情報を合わせる必要がある． 別名かどうか判定するには生物の種について考える必要があり，この問題はかなり根深くてややこしいため，ここではあえて立ち入らない． 単純に検索したものと同じ文字列の和名の目録Noを得ることを考える． tableの列名とその内容をもとにして目録Noを取得するには，dplyrのselectとfilterが便利だ． selectは列名を指定する以外に列番号を指定できるので，それを使う． さらに，filter，stringr，stringiの関数の合せ技でspと同じ文字列のnoを取り出す． 途中にちょっと面倒な点があるので，その点だけやや詳しく補足する． separate()のsep(区切り文字)として，stringi::stri_unescape_unicode(\"\\\\u00a0\")を指定している． これは，普通の半角スペースに見えるが，No-Break Spaceと言われる改行を防ぐ特殊なスペースである． これをそのままコードに入力しても良いが，どう見ても普通のスペースと見分けがつかない． 後からコードを書く時に普通のスペースを使ってしまうと，区分しようとしてもうまくいかない． そこで，これは普通のスペースではないことを明示的に示した． また，str_detect()の引数で，paste0(\"^\", sp, \"$\")としたのは，「ニッコウキスゲ」以外にマッチさせないためである． 例えば，「ギンラン」を検索すると，「ギンラン」以外にも「エゾギンラン」と「ササバギンラン」も出てくる． この場合に正規表現の^(行頭の意味)$(行末の意味)を使うことで，「ギンラン」にしかマッチさせない． no &lt;- rvest::html_table(html) %&gt;% `[[`(6) %&gt;% dplyr::select(no = 1, wamei = 4) %&gt;% tidyr::separate(wamei, into = &quot;wamei&quot;, sep = stringi::stri_unescape_unicode(&quot;\\\\u00a0&quot;), extra = &quot;drop&quot;) %&gt;% dplyr::filter(stringr::str_detect(wamei, paste0(&quot;^&quot;, sp, &quot;$&quot;))) %&gt;% `[[`(&quot;no&quot;) 14.7 URLの生成・データの取得 目録Noが取得できれば，完成したようなものである． ブラウザで表示した地図や指定状況のURLを生成する． “map&amp;q=0605009”の詳細な意味はよくわからないが，“0605009”あたりは分類群を指定しているのだと考えられる． これに維管束植物(コケなどを除くシダ植物と花の咲く植物)の中での目録Noを結合して，さらにmainを結合するとURLの出来上がりだ． show_sp &lt;- paste0(&quot;map&amp;q=0605009&quot;, no) paste0(main, show_sp) ## [1] &quot;http://jpnrdb.com/search.php?mode=map&amp;q=06050095259&quot; html &lt;- paste0(main, show_sp) %&gt;% rvest::read_html() 生成したURLをブラウザで表示させると地図ページが表示される． 一覧表の表示にしてもURLは変更されないため，内部的に表示を変更させている可能性が高い． そこで，とりあえずHTMLからtableデータの列名を確認する． なお，str_remove_all()で不要な文字の除去をしている． html %&gt;% rvest::html_table() %&gt;% purrr::map(colnames) %&gt;% purrr::map(stringr::str_remove_all, &quot;\\\\n|\\\\t|\\\\r&quot;) ## [[1]] ## [1] &quot;X1&quot; ## ## [[2]] ## [1] &quot;X1&quot; ## ## [[3]] ## [1] &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; &quot;X5&quot; &quot;X6&quot; ## ## [[4]] ## [1] &quot;都道府県名▲▼&quot; &quot;和名&quot; &quot;学名&quot; &quot;RDBカテゴリ名&quot; ## [5] &quot;統一カテゴリ&quot; ## ## [[5]] ## [1] &quot;ニッコウキスゲ学名：Hemerocallis dumortieri var. esculenta分類： 単子葉類 ユリ科 登録別名：環境省カテゴリ：なし都道府県のRDB指定状況：&quot; ## [2] &quot;ニッコウキスゲ&quot; ## [3] &quot;ニッコウキスゲ&quot; ## [4] &quot;学名：&quot; ## [5] &quot;Hemerocallis dumortieri var. esculenta&quot; ## [6] &quot;分類：&quot; ## [7] &quot;単子葉類 ユリ科&quot; ## [8] &quot;登録別名：&quot; ## [9] &quot;&quot; ## [10] &quot;環境省カテゴリ：&quot; ## [11] &quot;なし&quot; ## [12] &quot;都道府県のRDB指定状況：&quot; ## [13] &quot;&quot; ## ## [[6]] ## [1] &quot;X1&quot; &quot;X2&quot; 果たして，tableの4番目に欲しいデータがあった． あとは，filterで不要な都道府県データを除去する． さらに，データを分析するならば整形・変換・保存などをするが，スクレイピングとしての作業はここまでとする． html %&gt;% rvest::html_table() %&gt;% `[[`(4) %&gt;% dplyr::filter(和名 != &quot;-&quot;) ## # A tibble: 4 × 5 ## `都道府県名▲▼` 和名 学名 RDBカテゴリ名 統一カテゴリ ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;埼玉県\\r\\n ※&quot; &quot;ニッ… &quot;Heme… &quot;絶滅危惧Ⅱ類… &quot;&quot; ## 2 &quot;滋賀県&quot; &quot;ニッ… &quot;Heme… &quot;分布上重要… &quot;&quot; ## 3 &quot;島根県&quot; &quot;ニッ… &quot;Heme… &quot;絶滅危惧Ⅰ類… &quot;&quot; ## 4 &quot;※埼玉県・東京都・神奈川県では、季節… &quot;※埼… &quot;※埼… &quot;※埼玉県・… &quot;※埼玉県・… 14.8 地図画像の取得 指定状況の地図画像を取得するには，まずブラウザで画像のURLを得る必要がある． GoogleChromeで画像を右クリックして，「画像アドレスをコピー」を選択する． ニッコウキスゲの場合は，以下のURLを得ることができる． http://jpnrdb.com/png/06/06050095259.png 指定状況の一覧表データのHTMLにも(ほぼ)同じものが含まれているはずである． rvestで目的とするファイルのURLを得るコードは以下のとおりである． html %&gt;% rvest::html_elements(&quot;img&quot;) %&gt;% rvest::html_attr(&quot;src&quot;) %&gt;% `[`(., stringr::str_detect(. , as.character(no))) ## [1] &quot;./png/06/06050095259.png&quot; 上のコード使用したように，rvestで便利な関数としてhtml_elements()とhtml_attr()がある． それぞれ次のようにid，class，tag，属性によってHTMLからDOMを取得可能である． html_elements() html_elements(“#id”) html_elements(“.class”) html_elements(“tag”) html_attr(“attribute”) DOMとはドキュメントオブジェクトモデルのことで，HTMLの各要素をオブジェクトとするモデルのことである． id，class，tag，属性を指定することで，効率的にオブジェクトを取り出せて便利である． id，class，tag，属性についての詳細は，HTMLの解説などを別途参照していただきたい． 簡単に説明をすると，idはHTML内で一意に決定できるもので，日本のレッドデータ検索システムでは&lt;id = “header”&gt;などが使われている． classは，HTML内で複数出てくることがあり，&lt;class = \"kind_list\"&gt;のように指定される． tagは，上記の&lt;id&gt;や&lt;class&gt;を含めたすべてのタグのことで，他にも&lt;p&gt;，&lt;div&gt;，&lt;table&gt;など多くの物がある． html_table()はhtml_elements(\"table\")と同等であるが，tableタグは入手したいデータを含むことが多いため個別の関数が作成されたのだろう． 属性はtagの，「href = “index.html”」の部分で，html_attr(\"href\")とすると，“index.html”を取り出すことができる． hrefが複数ある場合は，すべてを含むベクトルが返り値になる． ただし実際には，上のようにブラウザでの右クリックか，以下の手順で実行するのが手っ取り早い． - ブラウザで地図ページを表示させる - F12を押して開発者ツールを開く - 左上の□と矢印の結合したアイコンをクリック後に画像をクリック - Elementsのところに出てきたURLが求めるURL - タグを右クリックして[Copy] - [Copy element] や [Copy outerHTML] で内容をコピーできる 画像のURLがわかれば，ファイルをダウンロードして保存する． これは，curlパッケージのcurl_download()で簡単にできる． 引数urlにはURLを，destfileにはダウンロード後のファイル名を指定する． パスを指定しないと作業ディレクトリ(getwd()で取得可能)に保存されるが，作業ディレクトリ以外に保存したい場合は，相対パスや絶対パスを指定する． # wd &lt;- &quot;set_your_directory&quot; # setwd(wd) url_img &lt;- &quot;http://jpnrdb.com/png/06/06050095259.png&quot; curl::curl_download(url = url_img, destfile = paste0(sp, &quot;.png&quot;)) このようにしてスクレイピングが可能ではあるが，URLの生成規則は，変更されることがある． read_html()でHTMLが取得できない場合は，URLを確認する． また，動的なサイトでは，idが固定ではない可能性がある． サイトの仕様変更によって，tag，class，その他の構造が変更されることがある点も注意しなければならない． 気象庁ではなく他のサイトの事例ではあるが，綺麗な構造のサイトであっても，手作業が混入していることはある． 例えば，括弧が正しく対応しているはずだと思っていても，開く側が”『“で閉じる側が”」“になっていることがあった． その場合に正規表現”『.+』“ではうまく鉤括弧内の文字列を取得できないことになる． 14.9 複数種への対応 前節のようにすれば，レッドデータへの指定状況とその地図データを得ることができる． 1種だけのデータ・画像の入手方法を紹介したが，複数種に対しても応用可能である． その際には，forループか，purrr::mapを使うと良いだろう． 複数ページのデータを取得する場合は一般的には5秒程度の間隔を置く必要がある． ただし，サイトによってはそれ以上の間隔を求めているときがある． その内容はドメインのトップに置かれた「robots.txt」で確認できる． “http://jpnrdb.com/\"には\"robots.txt\"が置かれていないが，politeパッケージの関数`bow()`でスクレイピングについて調べてみる． polite::bow(&quot;http://jpnrdb.com/&quot;) ## &lt;polite session&gt; http://jpnrdb.com/ ## User-agent: polite R package ## robots.txt: 1 rules are defined for 1 bots ## Crawl delay: 5 sec ## The path is scrapable for this user-agent 「Crawl delay: 5 sec」とあるため，5秒間隔でスクレイピング可能であると思われる． これ未満の間隔でデータを頻繁に求めると，「攻撃」と見なされて接続できな状態になる可能性がある． さらに悪質なときには法的手段を取られることもありえるので，注意が必要である． れらはpoliteパッケージが一般的な注意として示しているに過ぎない． 大量にデータを入手する必要がある場合は，あらかじめ管理者に連絡する方が無難である． 14.10 おまけ：webshotでウエブページを画像に変換 スクレイピングしたウエブページを画像として残しておきたいことがある． つまり，ウエブのスクリーンショットを保存したい場合だ． まさにこの文章を書いているときがそうだが，データを入手してそのサイトについて他人に説明したいときがあるだろう． そのようなときはパッケージwebshotが便利だ． 例によってまずはパッケージをインストールする． install.packages(&quot;webshot&quot;) webshotは内部でPhantomjsというブラウザを使っているので， webshotからPhantomjsをインストールするための関数を実行する． なお，Phantomjsはヘッドレス・ブラウザの1つである． ヘッドレス・ブラウザは，画面を描画しないブラウザのことである． つまり，画面上でHTMLを表示せずにデータのやり取りだけをするもので，プログラムやスクレイピングでは重宝する． webshot::install_phantomjs() イントールに若干時間がかかるが，終わればあとは簡単だ． 関数webshotにURLと保存するファイル名を指定すれば，画像を作業フォルダに保存してくれる． webshot::webshot(&quot;http://jpnrdb.com/search.php?mode=spec&quot;, &quot;rvest_1.png&quot;) webshot::webshot(&quot;http://jpnrdb.com/search.php?mode=key&amp;q=ニッコウキスゲ&quot;, &quot;rvest_2.png&quot;) webshot::webshot(&quot;http://jpnrdb.com/search.php?mode=map&amp;q=06050095259&quot;, &quot;rvest_3.png&quot;) なお，パッケージmagickを使うと保存した画像に対してトリミングなどの加工ができる． 参考：magickで画像編集 "],["rselenium.html", "Chap. 15 Rseleniumでスクレイピング 15.1 準備 15.2 ブラウザの自動化 15.3 15.4 要素の取得 15.5 その他", " Chap. 15 Rseleniumでスクレイピング Seleniumは，ブラウザを使って動的に巡回しつつ，スクレイピングをするのに適している． JavascriptやPHPなどを使って，動的に作成されるサイトでは，URLだけではページを特定することはできない． そのため，rvestだけではデータを取得するのが困難である． 15.1 準備 RSelenium: CRANからインストール Selenium: 本家サイトからインストール 注意: ver3.xxx をインストールする ver4.0 以上はRSeleniumが対応していない(Pythonなら可) ChromeDriver 注意: 自身の利用しているブラウザのドライバが必要(バージョンも合致する必要あり) GoogleChromeは自動的にupdateされるので，バージョンをよく確認する 通常は，安定版の最新版で大丈夫である Seleniumと同じフォルダに保存する install.packages(&quot;RSelenium&quot;) library(tidyverse) library(RSelenium) 15.2 ブラウザの自動化 15.3 15.3.1 使い方 15.3.2 注意点 15.4 要素の取得 idがわかるとき document.getElementByID() xpath document.selectQueryAll()[] 動的にサイトが作られているときには，変化する可能性があるので注意 使用されているJavaScriptの関数がわかる script &lt;- “” rem$excute(script) 例 BiSSの文字サイズの変更 主命リストの列数の変更 スクレイピングの実行時には，適切な時間間隔を空ける - 通常は5秒以上を求めていることが多い ページ遷移の命令を送信後，十分な間隔がないとHTMLの要素を取得しきれていないことがある 極端な場合，サーバーからの情報がほとんど何も送られていない，つまりページの内容がほとんど何もないことにある． この状況は，通常のマウス操作では何も表示されていないところをクリックするのと同じ状態である． サーバからの情報を待つ意味でも適度な間隔を空けるのが望ましい 動的なサイトの場合は，HTMLの構成中の可能性もある ログイン等のページでも，遷移途中のことがある． 15.5 その他 Rからシェルのコマンドを使う pngからPDFへ変換 ファイルの移動 Seleniumuの起動・終了 MeCabやGINZAの実行 "],["magick.html", "Chap. 16 magickで画像編集 16.1 準備 16.2 使い方 16.3 その他の関数 16.4 ウエブのスクリーンショットにURLを付加する関数", " Chap. 16 magickで画像編集 パッケージmagickを使うと，各種の画像編集ができる． magickは，画像編集ソフトであるImageMagickを使うためのパッケージである． ImageMagickは，png，gif，pdfなどをはじめ多くの画像形式を扱うことができ，拡大・縮小，形式変換，回転，切り出し，色加工など多くの機能を備えている． ImageMagick自体は，コマンドラインで使うことができるので，関数system()を使ってRから操作することもできる． でも，車輪の再発明は時間と労力の無駄なので，パッケージmagickを紹介する． 16.1 準備 例によってまずはパッケージをインストールする． svg形式の画像を読み込む場合は，rsvgパッケージもインストールしておく． ウエブのスクリーンショットを使うので，webshotも必要だ． install.packages(&quot;magick&quot;) install.packages(&quot;rsvg&quot;) install.packages(&quot;webshot&quot;) library(tidyverse) library(magick) library(webshot) 16.2 使い方 ImageMagick自体に多くの機能があり，magickでもその機能を利用できるため，1つ1つを紹介するとキリがない． ここでは，基本的な機能として画像の読み込み・変換・保存を紹介するとともに， rvestでスクレイピングで使用した画像を作成するために，実際に操作したコードを説明する． 16.2.1 読み込み・表示・変換・保存 png，jpeg，gif形式の画像にはimage_read()，svg形式にはimage_read_svg()，PDF形式にはimage_read_pdf()をそれぞれ用いる． 読み込んだ画像オブジェクトの情報を表示するには，image_info()を使う． 表示だけなら，オブジェクトをそのまま入力しても同じである． frink &lt;- magick::image_read(&quot;https://jeroen.github.io/images/frink.png&quot;) tiger &lt;- magick::image_read_svg(&quot;http://jeroen.github.io/images/tiger.svg&quot;) image_info(frink) ## # A tibble: 1 × 7 ## format width height colorspace matte filesize density ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; &lt;chr&gt; ## 1 PNG 220 445 sRGB TRUE 73494 72x72 image_info(tiger) ## # A tibble: 1 × 7 ## format width height colorspace matte filesize density ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;int&gt; &lt;chr&gt; ## 1 PNG 900 900 sRGB TRUE 0 72x72 画像そのものを表示するには，image_browse()を用いる． OSで関連付けられているソフトが立ち上がって，画像を閲覧できる． magick::image_browse(tiger) image_convert()を用いると画像をpng，jpeg，gif，pdf形式に変換できる． 画像形式は，formatで指定する． また，type = \"grayscale\"とすると，白黒画像似できる． magick::image_convert(tiger, format = &quot;pdf&quot;) %&gt;% magick::image_browse() 画像を保存するには，関数image_write()を使う． この関数の引数にもformatがあり，ここで形式を変換することもできる． image_write()のpathで拡張子を含むファイル名を指定しても，自動的にはその拡張子の形式としては保存されない． 形式を変換したい場合は，formatで形式をしていしなければならない． formatを指定しなければ，もとの画像の形式のまま保存される． magick::image_write(frink, path = &quot;frink.pdf&quot;, format = &quot;pdf&quot;) magick::image_write(frink, path = &quot;frink&quot;) 16.2.2 切り抜き 画像を切り抜きする前に，webshotを使って画像を取得する． # 画像の取得 urls &lt;- list(&quot;http://jpnrdb.com/search.php?mode=spec&quot;, &quot;http://jpnrdb.com/search.php?mode=key&amp;q=ニッコウキスゲ&quot;, &quot;http://jpnrdb.com/search.php?mode=map&amp;q=06050095259&quot;) pngs &lt;- paste0(&quot;rvest_&quot;, 1:3, &quot;.png&quot;) purrr::map2(urls, pngs, webshot::webshot) ## [[1]] ## ## [[2]] ## ## [[3]] image_crop()をそのまま使っても便利ではあるが，切り出しサイズ・位置の指定方法がどうも個人の性に合わない． そのためラッパー関数で，切り出したい左上の位置と右下の位置を指定できるようにする． 切り出しの左上と右下の位置は，画像編集ソフトなどで別途確認する． もし，切り出しの位置の細かな設定が面倒であれば，いくつかのパターンを作っておき，総当たり的に画像を切り出して，その中から求めるものを探す方法もある． その場合は，出力したファイルがどの設定によるものか分かるように，出力するファイル名に位置情報を付与しておくと良いだろう． magick_crop &lt;- function(image, left_top, right_bottom){ left &lt;- left_top[1] top &lt;- left_top[2] right &lt;- right_bottom[1] bottom &lt;- right_bottom[2] geometry &lt;- paste0(right - left, &quot;x&quot;, bottom - top, &quot;+&quot;, left, &quot;+&quot;, top) magick::image_crop(image, geometry) } 今回は切り出し位置として2つ使う． 1つ目は，rvest_1.pngとrvest_2.pngで使うもので，2つ目は，rvest_3.pngで使うものである． それぞれの正しい設定だけを使ってコードを書いても良いが，面倒なのでとりあえず2つの位置を使って，画像を3つとも変換してしまう． 変換後に実際に必要な画像だけを使えば良い． ところで，magickパッケージの関数ベクトルに対応しているので，文字列のベクトルであるpngsでもそのまま引数として使うことができる． ただし，2つのベクトルを引数に使うことはできないため，以下ではmap2を使っている． また，その直前で返り値をリストに変換するためにas.list()を使っている． crop_1 &lt;- magick::image_read(pngs) %&gt;% magick_crop(c(100, 0), c(890, 560)) %&gt;% as.list() %&gt;% purrr::map2_chr(., paste0(&quot;crop1_&quot;, pngs), magick::image_write) crop_2 &lt;- magick::image_read(pngs) %&gt;% magick_crop(c(100, 0), c(890, 980)) %&gt;% as.list() %&gt;% purrr::map2_chr(., paste0(&quot;crop2_&quot;, pngs), magick::image_write) crops &lt;- c(crop_1[c(1,2)], crop_2[3]) ここでは，image_crop()を使用したが，上下左右から変化がない部分を除去するimage_trim()という関数がある． 余白部分(色は白だけとは限らない)を単純に除去するだけでれば，位置を指定する必要のないimage_trim()`の方が楽である． 16.2.3 サイズの変更 画像サイズを変更するには，image_scale()を使う． geometry = \"200\"で幅200ピクセルに，geometry = \"x200\"で高さ200ピクセルに変更できる． なお，縦横比を保ったままである． resizes_crops &lt;- magick::image_read(crops) %&gt;% magick::image_scale(geometry = &quot;600&quot;) 16.2.4 枠(余白)の追加・註釈(テキスト)の追加 画像に枠(余白)と註釈(テキスト)をつけるには，それぞれimage_border()とimage_annotate()を使う． image_border()でgeometry = \"x40\"は上下に，geometry = \"40\"は左右に 40ピクセルの枠を追加する． image_annotate()は位置location，角度degrees，文字サイズsize，フォントfontなども指定可能である． boders_annotates &lt;- resizes_crops %&gt;% magick::image_border(&quot;white&quot;, geometry = &quot;x40&quot;) %&gt;% as.list() %&gt;% purrr::map2(., urls, magick::image_annotate, size = 20) 16.3 その他の関数 magickには，他にも有用な関数がたくさんある． image_append(image, stack = FALSE) # 並べて表示，stack = TRUEで縦並べ image_background(image, color) # 背景の色付け image_rotate(image, degrees) # 回転 image_blur(image, radius, sigma) # ぼかし処理．radius，sigma：ぼかしの大きさ image_noise(image, noisetype) # ノイズの追加 image_charcoal(image, radius, sigma) # 縁取り image_oilpaint(image, radius) # 油絵 image_edge(image, radius) # エッジ image_negate(image) # ネガ image_morph(image, frames) # 画像を指定したframes間隔 image_animate(image, fps, loop) # image_morph()画像のアニメ化，fps：frames/秒，`loop = 1`で繰り返しなし 16.4 ウエブのスクリーンショットにURLを付加する関数 これまでの内容をもとに，ウエブのスクリーンショットにURLを付加する関数を作成する． 主な流れは次のとおりである． 一時ファイル名を生成 一時ファイルにURLで指定したウエブのスクリーンショットを保存 スクリーンショットを読み込み，一時ファイルの削除 余白のトリミング(オプション) URLを書き込む白色の枠を上下に追加 URLの追加 下側の白色の枠の削除 形式の変換(オプション) サイズの変更(オプション) #&#39; Donwload screenshot image from web based on URL and add text annotation of URL on the top of the image. #&#39; #&#39; Needs #&#39; #&#39; @param url A string of URL. #&#39; @param trim A logical if trim image by magick::image_trim(). #&#39; @param border_size A string of border size. &quot;x40&quot;: Set border on the top for annotation. #&#39; Will be passed like imagick::image_border(img, &quot;white&quot;, geometry = border_size). #&#39; @param annotate_size A string of annnotation size. #&#39; Will be passed like magick::image_annotate(img, url, size = annotate_size) #&#39; @param format A string of format of image. #&#39; Will be passed like magick::image_convert(img, format = format) #&#39; @param resize A string for resize by magick::image_scale(). #&#39; Passed like magick::image_scale(geometry = resize). #&#39; @return An magick-image object. #&#39; @examples #&#39; # install.packages(&quot;magick&quot;) #&#39; # install.packages(&quot;webshot&quot;) #&#39; url &lt;- &quot;https://www.deepl.com/translator&quot; #&#39; tmp &lt;- web_screenshot(url, format = &quot;png&quot;) #&#39; magick::image_browse(tmp) #&#39; magick::image_write(&quot;deepl.png&quot;) #&#39; #&#39; @export web_screenshot &lt;- function(url, trim = TRUE, border_size = &quot;x40&quot;, annotate_size = 20, format = &quot;png&quot;, resize = FALSE){ png &lt;- fs::file_temp(ext = &quot;png&quot;) webshot::webshot(url, png) img &lt;- magick::image_read(png) file_delete(path) if(trim){ img &lt;- magick::image_trim(img) } # add top margin (removed bottom margin by image_crop) img &lt;- magick::image_border(img, &quot;white&quot;, geometry = border_size) crop_size &lt;- stringr::str_split(border_size, pattern = &quot;x&quot;, simplify = TRUE)[2] h &lt;- magick::image_info(img)$height - as.numeric(crop_size) img &lt;- magick::image_crop(img, geometry = paste0(&quot;x&quot;, h)) img &lt;- magick::image_convert(img, format = format) # add annotation img &lt;- magick::image_annotate(img, url, size = annotate_size) if(resize != FALSE){ img &lt;- magick::image_scale(geometry = risize) } return(img) } "],["dbi.html", "Chap. 17 DBIでデータ取得 17.1 データベースとの連携 17.2 DBIでできること 17.3 準備 17.4 使い方", " Chap. 17 DBIでデータ取得 17.1 データベースとの連携 リレーショナル・データベースと接続してデータを取得するためのパッケージには色々とある． CRAN Task View: Databases with R には多くのパッケージが掲載されている． https://cran.r-project.org/web/views/Databases.html どれを使っても良いが，よく使われているのはDBIのようだ． https://cran.r-project.org/web/packages/DBI/index.html 17.2 DBIでできること 各種データベースとの接続 SQLによるデータ操作 SQLを使い慣れていれば，SQLで各種の操作をするのが良いだろう． 一方，Rでのデータフレームの操作に慣れていれば，取得したデータをRで操作するのが良い． つまり，データ取得だけにDBIを利用して，その後はdplyrやtidyverseの各種パッケージの関数を駆使してデータを処理する． さらに，その結果を図示したい場合は，ggplot2を使うと良い． 17.3 準備 install.packages(c(&quot;DBI&quot;, &quot;RSQLite&quot;)) library(tidyverse) library(DBI) library(RSQLite) # 一時的データの準備 con &lt;- dbConnect(RSQLite::SQLite(), dbname = &quot;:memory:&quot;) dbWriteTable(con, &quot;mpg&quot;, mpg) dbListTables(con) ## [1] &quot;mpg&quot; 17.4 使い方 # SQLで選択・フィルタ res &lt;- dbSendQuery(con, &quot;SELECT year, model, displ, cyl FROM mpg WHERE cyl = 4&quot;) df &lt;- dbFetch(res) dbClearResult(res) tibble::as_tibble(df) ## # A tibble: 81 × 4 ## year model displ cyl ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1999 a4 1.8 4 ## 2 1999 a4 1.8 4 ## 3 2008 a4 2 4 ## 4 2008 a4 2 4 ## 5 1999 a4 quattro 1.8 4 ## 6 1999 a4 quattro 1.8 4 ## 7 2008 a4 quattro 2 4 ## 8 2008 a4 quattro 2 4 ## 9 1999 malibu 2.4 4 ## 10 2008 malibu 2.4 4 ## # ℹ 71 more rows # とりあえず全部取得してから，dplyrで選択・フィルタ res &lt;- dbSendQuery(con, &quot;SELECT * FROM mpg&quot;) df &lt;- dbFetch(res) dbClearResult(res) df %&gt;% tibble::as_tibble() %&gt;% print() %&gt;% dplyr::select(year, model, displ, cyl) %&gt;% dplyr::filter(cyl == 4) %&gt;% head() ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… ## # ℹ 224 more rows ## # A tibble: 6 × 4 ## year model displ cyl ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1999 a4 1.8 4 ## 2 1999 a4 1.8 4 ## 3 2008 a4 2 4 ## 4 2008 a4 2 4 ## 5 1999 a4 quattro 1.8 4 ## 6 1999 a4 quattro 1.8 4 SQL使いの方は，「SQLではじめるデータ分析 ―クエリで行う前処理、時系列解析、コホート分析、テキスト分析、異常検知」を参考にしてSQLでデータ処理をするのも良いだろう． しかし，R使いにとってはdplyrやggplot2を使って処理するほうが楽だと思われる． dplyrやggplot2を使ったデータ分析には，「Rではじめるデータサイエンス」が参考になる． https://r4ds.hadley.nz/ その他，DBIパッケージの詳細は以下を参照． https://cran.r-project.org/web/packages/DBI/vignettes/DBI-1.html "],["xlsx.html", "Chap. 18 xlsxでエクセル操作 18.1 準備 18.2 オートフィルタの設定とウィンドウ枠の固定の自動化スクリプト 18.3 その他の操作(未作成)", " Chap. 18 xlsxでエクセル操作 xlsxパッケージを使うと，エクセルのファイルの読み込み・書き込みをはじめ， オートフィルタの設定やウィンドウ枠の固定などの各種操作が可能である． 18.1 準備 library(tidyverse) 18.2 オートフィルタの設定とウィンドウ枠の固定の自動化スクリプト xlsxの使用例として，オートフィルタを設定して・ウィンドウ枠を固定する自動化スクリプトを作成した． 18.2.1 使用方法 準備：Rのインストール 準備：set_autofilter_freezepanel.rsc をダウンロード(右クリックして「名前を付けてリンク先を保存」)して，任意のフォルダに保存． 準備：スクリプトの関連付けを参考にして，「.rsc」を「Rscript.exe」に関連付けする(Windowsの場合)．Macの場合は，Mac - 拡張子に関連付けられているアプリを変更する方法などを参考にしてほしい． set_autofilter_freezepanel.rsc と同じフォルダに，処理したいエクセルのファイルを保存． 実行前のエクセルのファイル set_autofilter_freezepanel.rsc をダブルクリックして実行すると，黒い画面が表示されてプログラムが実行される． プログラムが自動的にエクセルのファイルの1行目のA列からZ列までにオートフィルタを設定し，1行目と1列目でウィンドウ枠を固定する． 複数ファイル・複数シートにも対応している． なお，初回実行時は，xlsxパケージのダウンロードのため，少し時間がかかるかもしれない． 2回目以降はファイル数が多すぎなければ，一瞬で処理されるはず． 実行後のエクセルのファイル 18.2.2 スクリプトの内容説明 # Package, 準備 if(! &quot;xlsx&quot; %in% installed.packages()[,1]){ # xlsxパッケージ有無の確認 # パッケージが無い場合 options(repos = &quot;https://cran.ism.ac.jp/&quot;) # ミラーサイトの設定 install.packages(&quot;xlsx&quot;) # パッケージのインストール } # Functions, 関数 # 註：xlsxパッケージの関数は返り値の代入がない # 副作用でシートなどを操作するため? # 参照型を使っているため? # 参考：通常のRの関数は，返り値の代入をすることが多いの # オートフィルタの設定 set_auto_filter &lt;- function(sh){ # A1からZ1までを設定 # もっと多くの列で設定したければ，&quot;A1:Z1&quot;のところを修正する xlsx::addAutoFilter(sh, &quot;A1:Z1&quot;) } # ウィンドウ枠の固定 set_freeze_panel &lt;- function(sh){ # 1列目と1行目のウィンドウ枠を固定 # 固定する場所の変更方法 # 2行目までを固定したい場合は，引数の2つ目と4つ目を，3にする # 3列目までを固定したい場合は，引数の3つ目と5つ目を，4にする xlsx::createFreezePane(sh, 2, 2, 2, 2) } # ワークブックごとで設定 set_af_fp &lt;- function(file){ wb &lt;- xlsx::loadWorkbook(file) # ワークブックの読み込み for(sh in xlsx::getSheets(wb)){ # シートの数だけ繰り返し set_auto_filter(sh) # オートフィルタの設定 set_freeze_panel(sh) # ウィンドウ枠の固定 } xlsx::saveWorkbook(wb, file) # ワークブクの保存 } # Main, 本体 files &lt;- list.files(pattern = &quot;xls&quot;) # &quot;.xls&quot;と&quot;xlsx&quot;の一覧取得 for(file in files){ # ファイルの数だけ繰り返し set_af_fp(file) # set_af_fp()の実行 } 18.3 その他の操作(未作成) "],["qpdf.html", "Chap. 19 qpdfでPDF操作 19.1 準備 19.2 qpdfでできること 19.3 PDFの分割 19.4 PDFの結合 19.5 PDFの圧縮・最適化 19.6 PDFへのページ番号付加 19.7 その他の関数 19.8 pdftoolsでテキストの取り出し", " Chap. 19 qpdfでPDF操作 19.1 準備 いつものように，まずパッケージをインストールする． qpdfはPDF操作のためのパッケージである． 著者作パッケージのであるautomaterをインストールするが，これはCRANには登録していない． いずれはCRANに登録したいと思っているが，現段階ではGitHubで公開している． そのため，install.packages()ではなく，devtools::install_github()を使ってインストールする． install.packages(&quot;qpdf&quot;) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;matutosi/automater&quot;) library(tidyverse) library(qpdf) library(automater) 19.2 qpdfでできること qpdfパッケージでは，PDFファイルのページ分割・抽出・結合・回転・圧縮・重ね合わせが可能である． あくまでページ単位での操作で，PDFに含まれるテキスト自体の編集はできない． ページ単位でのPDF操作は，Adobe AcrobatでなくてもCubePDF UtilityやPDFtkを使えば可能である． PDFtkはコマンドラインでの操作も可能であるため，大量の操作をするには適している． とはいえ，Rやそのパッケージで操作が自動化できればさらに便利である． なお，PDF関連の他のパッケージとしてはpdftoolsがある． pdftoolsではテキスト抽出，OCR(画像の文字認識，内部でtesseractパッケージを使用)，PDFファイルの分割・結合(内部でqpdfパッケージの関数を使用)，画像ファイルへの変換などができる． また，Microsoft365Rを使えばPDFをワードに変換できる． Microsoft365R 余談であるが，Rのパッケージはそれぞれ独自コードを持つ部分がある一方で，他のパッケージの関数をインポートしているものや，ラッパー関数を用意しているものなどがある． 例えば，automaterではそれ自体で有用な機能を持っているというよりは，他のパッケージを利用しやすくするためのラッパー関数の集合である． そのため，automaterのコードをもとにさらに使いやすく改良可能であり，各自で試してほしい． 19.3 PDFの分割 PDFの分割は非常に簡単である． pdf_split()関数にinput引数として分割するファイルを，output引数として出力パスを指定すれば良い． パスワードが必要な場合は，引数passwordを指定する． # wd &lt;- &quot;set_your_directory&quot; # setwd(wd) review &lt;- curl::curl_download( &quot;https://www.jstage.jst.go.jp/article/vegsci/31/2/31_193/_pdf/-char/ja&quot;, fs::file_temp(ext = &quot;pdf&quot;) ) split_pdf &lt;- qpdf::pdf_split(review) head(split_pdf) ファイル名の文字列のベクトルが返り値なので，それをもとにしてファイル名を変更すると実用的な自動化ができるだろう． ページを指定した抽出も可能で，pdf_subset()関数を使用する． 引数としてpagesを指定する以外は，pdf_split()と同じ使い方である． # 指定ページを抽出，create a new pdf with a subset of the input pages pdf_subset(input, pages = 1, output = NULL, password = &quot;&quot;) 以下の内容は，パッケージautomaterのinst/rscディレクトリにあるsplit_qpdf.rscの内容である． 拡張子.rscをRscriptに関連付けすれば，split_qpdf.rscと同じフォルダに保存したPDFファイルをsplit_qpdf.rscをクリックするだけで分割できる． 拡張子の関連付けは，スクリプトの関連付けを参照して欲しい． system.file(&quot;rsc/split_qpdf.rsc&quot;, package = &quot;automater&quot;) %&gt;% readLines() %&gt;% paste0(collapse = &quot;\\n&quot;) %&gt;% cat() ## # # # # # # # # # # # # # # # # # # # ## # ## # See https://github.com/matutosi/automater/blob/main/vignettes/split_qpdf.md ## # ## # # # # # # # # # # # # # # # # # # # ## ## # Prepare ## pkg &lt;- &quot;devtools&quot; ## if(! pkg %in% installed.packages()[,1]){ ## install.packages(pkg, repo = &quot;https://cran.ism.ac.jp/&quot;) ## } ## ## pkg &lt;- &quot;automater&quot; ## ver &lt;- utils::packageDescription(pkg, fields = &quot;Version&quot;) ## if(utils::compareVersion(ver, &quot;0.2.0&quot;) &lt; 0){ ## devtools::install_github(&quot;matutosi/automater&quot;, upgrade = &quot;never&quot;, force = TRUE) ## } ## ## automater::validate_package(&quot;qpdf&quot;) ## automater::validate_package(&quot;stringr&quot;) ## ## # Run ## files &lt;- list.files(pattern = &quot;\\\\.pdf&quot;) ## for(file in files){ ## output &lt;- qpdf::pdf_split(file) ## n_page &lt;- qpdf::pdf_length(file) ## extra &lt;- 0 # to avoid dupulicated file name, add extra degits ## numbered &lt;- automater::file_numbered(file, n_page, extra = extra) ## while(automater::is_duplicated(files, numbered)){ ## extra &lt;- extra + 1 ## numbered &lt;- automater::file_numbered(file, n_page, extra = extra) ## } ## file.rename(output, numbered) ## } ## ## automater::message_to_continue() # system.file(&quot;rsc/split_qpdf.rsc&quot;, package = &quot;automater&quot;) %&gt;% # readtext::readtext(verbosity = 0) %&gt;% # `[[`(&quot;text&quot;) %&gt;% # cat() 具体的な方法は次のとおりである． - split_qpdf.rsc をディレクトリーに保存する - 以下のコードで split_qpdf.rsc をコピー可能 file &lt;- &quot;split_qpdf&quot; path &lt;- &quot;c:/&quot; # set your path automater::set_rsc(file, path) 拡張子 .rsc を Rscript.exe に関連付ける 分割したいPDFファイルを split_qpdf.rsc と同じディレクトリにコピーする split_qpdf.rsc をクリックする 黒いウィンドウが開くので，しばらく待つ split_qpdf.rsc を初めて実行するときは，パッケージのインストールに時間がかかることがある． 出力ファイル名は以下のとおりである． - 入力：「original.pdf」(15ページ) - 出力: “original_01.pdf”, “original_02.pdf”, …, “original_15.pdf” 19.4 PDFの結合 結合させる場合は，input引数に結合させたいファイル名を指定する． それ以外は，pdf_split()と同様である． # 結合，join several pdf files into one pdf_combine(input, output = NULL, password = &quot;&quot;) 特定のディレクトリ内のPDFファイルを1つのPDFファイルとして結合することを自動化するスクリプトは以下のとおりである． system.file(&quot;rsc/combine_qpdf.rsc&quot;, package = &quot;automater&quot;) ## [1] &quot;D:/pf/R/R-4.3.0/library/automater/rsc/combine_qpdf.rsc&quot; readLines() %&gt;% paste0(collapse = &quot;\\n&quot;) %&gt;% cat() combine_qpdf.rsc をディレクトリに保存 以下のコードで、combine_qpdf.rsc をコピー可能 file &lt;- &quot;combine_qpdf&quot; path &lt;- &quot;c:/&quot; # set your path automater::set_rsc(file, path) 拡張子 .rsc を Rscript.exe に関連付ける 結合したいPDFファイルを combine_qpdf.rsc と同じディレクトリにコピーする ファイルの結合順はファイル名の順序と同じ combine_qpdf.rsc をクリックする 黒いウィンドウが開くので，しばらく待つ 初めて実行するときは，パッケージのインストールに時間がかかることがある． 結合したファイル名は以下のとおりである． 出力: 「combined_“2020-11-27_12_00_00.pdf”」(結合した日付・時刻) PDFファイルの結合順はファイル名の順序と同じなので，fs::dir_ls()でファイル名一覧を取得し，file_move()で名前を変更する必要がある． さらに，このあたりも自動化するには，ユーザからの入力を受け取り，それをもとにファイル名の順序を決めれば良い． # wd &lt;- &quot;set_your_directory&quot; # setwd(wd) library(tidyverse) input_files &lt;- function(files){ len &lt;- length(files) %&gt;% log10() %&gt;% ceiling() no &lt;- stringr::str_pad(seq(files), width = len, side = &quot;left&quot;) prompt &lt;- files %&gt;% paste0(no, &quot;: &quot;, .) %&gt;% paste0(collapse = &quot;\\n&quot;) %&gt;% paste0(&quot;\\n結合するファイルを番号で指定してください(カンマ区切り)．\\n 例：3,1,2\\n&quot;) %&gt;% cat() input_order &lt;- user_input(prompt) %&gt;% stringr::str_split(&quot;,&quot;) %&gt;% unlist() %&gt;% as.numeric() files[input_order] } user_input &lt;- function(prompt){ if (interactive()) { return(readline(prompt)) } else { cat(prompt) return(readLines(&quot;stdin&quot;, n=1)) } } files &lt;- fs::dir_ls(regexp = &quot;\\\\.pdf&quot;) input &lt;- input_files(files) input automater::message_to_continue() 上のコードのinput_files()では，ファイル名の一覧からファイル数を取り出し，ファイル番号を画面表示用に桁揃えしている． その後，ファイル番号とファイル名，さらにユーザへの註釈を結合して，プロンプトに表示するメッセージ文字列を生成する． メッセージをuser_input()を用いて表示するとともに，ユーザからの入力を受け取る． 入力された文字列を数値にして，ファイルの順序を決めている． このコードのinputをpdf_combine(input)として使えば，ユーザ入力をもとにしてPDFファイルを結合するスクリプトができる． 入力する番号が数個であれば，これでも良いがもっと多くのファイルになった場合は現実的には使いにくい． 多くのファイルを結合する場合は，以下のような方法で実装すると良いだろう． fs::dir_ls(regexp = \"\\\\.pdf\")でファイル名の一覧を入手 一覧をもとに1行ごとに1つのファイル名のテキストファイルとして保存 テキストファイルをユーザが並び替える(Rでは並び替えが終わるまで待機) 並び替えが終われば，RでEnter(他のキーでもOK)を入力 テキストファイルを読み込み，やcombine_qpdf()(pdf_combine()でもOK)でPDFを結合 19.5 PDFの圧縮・最適化 pdf_compress()は圧縮や最適化(Linealize)をしてくれる． 最適化されていないPDFはファイルを全部読み込まないと表示できないのに対して， 最適化されたPDFは最後まで読み込みが完了しなくてもページ表示できる． ネット上にある重いPDFを表示させる場合に特に役立つ． 使い方は次のとおりである． 詳細な説明は不要だろう． # 圧縮，compress or linearize a pdf file # 最適化する場合は，linearize = TRUE pdf_compress(input, output = NULL, linearize = FALSE, password = &quot;&quot;) 19.6 PDFへのページ番号付加 pdf_overlay_stamp()を使うと，PDFファイルに別のPDFファイルを重ね合わせることができる． pdf_overlay_stamp(input, stamp, output = NULL, password = &quot;&quot;) 引数inputにはベースとなるPDFファイルを，stampには重ね合わせるPDFファイルを指定する． stampとして「部外秘」「資料1」などを記載したPDFファイルをあらかじめ準備しておく． inputの各ページにstampの1ページ目が重ね合わせられる． これだけでも十分便利な機能であるが，さらに便利に使いたい． 例えば，ベースのPDFファイルの各ページにページ番号を入力したい． ページ番号でなくて別の通し番号を使いたいときもあるだろう． 例えば，学会の発表要旨集で左上に「A01」「A02」のような会場番号と通し番号を使うことが多い． さらに欲をだして，重ね合わせの開始・終了ページを指定するようにしたい． これらの内容を実行するコードは次のとおりである． #&#39; Wrapper functions to overlay page numbers and others using package qpdf. #&#39; #&#39; pdf_overlay_stamps_each() overlay PDF for each page in pdf file. #&#39; validate_page() is a helper function for pdf_overlay_stamps_each() #&#39; to validate page consistency of among page no. of input, stamp, start and end. #&#39; pdf_overlay_page_num() and pdf_overlay_session_num() are wrapper functions to #&#39; overlay page no. and session no. for accademic congress or symposium etc. #&#39; pdf_overlay_page_num() can overlay up to 100 pages. #&#39; #&#39; Package qpdf &lt;https://cran.r-project.org/web/packages/qpdf/index.html&gt; #&#39; includes useful functions as shown bellow. #&#39; pdf_length(), pdf_split(), pdf_subset(), pdf_combine(), #&#39; pdf_compress(), pdf_rotate_pages(), pdf_overlay_stamp(). #&#39; #&#39; @name pdf_overlay #&#39; @param input,stamp A string of file name or path of pdf file. #&#39; input is a base pdf and stamp will be overlayed. #&#39; No. of pages in stamp PDF should be equal to or over no. of pages in input PDF. #&#39; Pages in stamp exceeding pages over input pages will be ignored. #&#39; @param start,end An integer of start and end page to be stamped. #&#39; negative integer can be used for end, which means #&#39; number from the last page. #&#39; @param len_input,len_stamp An integer to validate. #&#39; @param session A string of session name. Can use &quot;a&quot;, &quot;b&quot;, or &quot;p&quot;. #&#39; &#39;session = &quot;a&quot;&#39; uses &#39;pdf/00_sn_a.pdf&#39; as stamp. #&#39; pdf directory include &#39;00_sn_a.pdf&#39;, &#39;00_sn_b.pdf&#39;, and &#39;00_sn_p.pdf&#39; #&#39; by default, which invlude 50 pages (eg., A01, A02, ..., A50) respectively. #&#39; @examples #&#39; \\dontrun{ #&#39; input &lt;- system.file(&quot;pdf/00_sn_a.pdf&quot;, package = &quot;automater&quot;) #&#39; pdf_overlay_page_num(input, start = 11, end = -3) #&#39; pdf_overlay_session_num(input, session = &quot;b&quot;) #&#39; } #&#39; #&#39; @return A string of output pdf file. #&#39; @export pdf_overlay_stamps_each &lt;- function(input, stamp, start = 1, end = NULL){ len_input &lt;- qpdf::pdf_length(input) len_stamp &lt;- qpdf::pdf_length(stamp) if(is.null(end)){ end &lt;- len_input } if(end &lt; 0 ){ end &lt;- len_input + end} validate_page(len_input, len_stamp, start, end) pages_inputs &lt;- seq(to = len_input) # +1 means out of bounds, inputs[pages_pre]: NA pages_pre &lt;- if(start != 1 ){ seq(to = start - 1) } else { len_input + 1 } pages_post &lt;- if(end != len_input){ seq(from = end + 1, to = len_input)} else { len_input + 1 } pages_body &lt;- pages_inputs[-c(pages_pre, pages_post)] inputs &lt;- qpdf::pdf_split(input) stamps &lt;- qpdf::pdf_split(stamp) out &lt;- list() for(i in seq_along(pages_body)){ out[[i]] &lt;- qpdf::pdf_overlay_stamp(inputs[pages_body[i]], stamps[i]) } out &lt;- stats::na.omit(c(inputs[pages_pre], unlist(out), inputs[pages_post])) outfile &lt;- qpdf::pdf_combine(out, &quot;out.pdf&quot;) file.remove(inputs) file.remove(stamps) file.remove(out[pages_body]) return(outfile) } #&#39; @rdname pdf_overlay #&#39; @export validate_page &lt;- function(len_input, len_stamp, start, end){ if(end &lt; start) { stop(&quot;end must be larger than start!&quot;) } if(len_input &lt; start) { stop(&quot;input pages must be larger than start!&quot;) } if(len_input &lt; end ) { stop(&quot;input pages must be larger than end!&quot;) } if(len_input &gt; len_stamp){ stop(&quot;stamp pages must be equal to or bigger than input!&quot;) } } #&#39; @rdname pdf_overlay #&#39; @export pdf_overlay_page_num &lt;- function(input, start = 1, end = NULL){ stamp &lt;- file.path(find.package(&quot;automater&quot;), &quot;pdf/00_page.pdf&quot;) pdf_overlay_stamps_each(input, stamp, start, end) } #&#39; @rdname pdf_overlay #&#39; @export pdf_overlay_session_num &lt;- function(input, start = 1, end = NULL, session = &quot;a&quot;){ stamp &lt;- file.path(find.package(&quot;automater&quot;), &quot;pdf/00_sn_&quot;, session, &quot;.pdf&quot;) pdf_overlay_stamps_each(input, stamp, start, end) } pdf_overlay_stamps_each()の引数には，input，stamp，start，endがある． inputとstampはqpdfの他の関数と同様の引数で，ファイルのパスを文字列で指定する． startとendは，inputでの重ね合わせ対象とするページ数の開始・終了ページで，整数で指定する． 最後からのページ数とするには，endを負の数で指定する． 関数の主な構成は以下のとおりである． - inputとstampのページ数を取得 -startやendとの整合性をvalidate_page()で確認 - 重ね合わせ対象よりも前(pages_pre)，後ろ(pages_post)，重ね合わせの対象のページ(pages_body)を取得 -pdf_split()でinputとstampを1ページごとに分割 -pages_bodyの部分のみ，stampの各ページを重ね合わせ - combine_pdf()で使うためのファイル名を結合(pages_pre，pages_body，pages_post`) - combine_pdf()でファイルの結合 - 使用後のファイルを削除 - 結合したファイル名を返す なお，ページ番号と学会でのセッション番号を付与するためのラッパー関数として，それぞれpdf_overlay_page_num()とpdf_overlay_session_num()がある． pdf_overlay_page_num()は，inputのPDFだけ指定すれば全ページに番号を付加し，startとendが指定可能である． ただし，最大ページ数は100ページである． pdf_overlay_session_num()は，さらにsessionを指定して「A01」のような番号を左上に付加する． pdf_overlay_page_num(input, start = 1, end = NULL) pdf_overlay_session_num(input, start = 1, end = NULL, session = “a”) パッケージautomaterのpdfフォルダには，ページ番号と学会でのセッション番号を付加するためのPDFファイル(すべてA4版)がある． - 00_page.pdf - 00_sn_a.pdf，00_sn_b.pdf，00_sn_p.pdf ページ番号は，下部に「-1-」などの表記があり100ページ分からなる． セッション番号は，左上に「A01」(A会場を想定)「B01」「P01」(ポスター会場を想定)などの表記があり，50番までが入っている． それぞれのtexソースファイルも保存されている． texを使うのが難しければ，ワードなどで同様の書式のファイルを作成したものをPDFとして保存すれば良い． 19.7 その他の関数 これまでで説明した以外に，qpdfにはpdf_length()とpdf_rotate_pages()がある． pdf_length()は入力したPDFファイルのページ数を返す． pdf_rotate_pages()はPDFファイルのページを90度単位で回転できる． angleで時計回りの角度を指定する． relativeがTRUEのときは入力時点での角度からの相対的な角度で回転し，FALSEのときはangle = 0のときは縦長でangle = 90のときは横長になる． pdf_length(input, password = &quot;&quot;) pdf_rotate_pages(input, pages, angle = 90, relative = FALSE, output = NULL, password = &quot;&quot;) 19.8 pdftoolsでテキストの取り出し pdftoolsパッケージでは，テキスト抽出，OCR(画像の文字認識)，PDFファイルの分割・結合，画像ファイルへの変換などができる． このうち，OCRではtesseractパッケージを，PDFの分割・結合ではqpdfパッケージの関数を使っており，直接それぞれのパッケージを使うのと基本的には同じ，画像ファイルへの変換はmagickパッケージで可能である． そのため，ここでは他のパッケージでは実装していないテキスト抽出を説明する． なお，テキスト抽出にはpopplerを使っている． Windows版のpdftoolsパッケージではpopplerが含まれているのでパッケージのインストールだけで使用可能である． MacやLinuxでは，popplerを別途インストールしなければならない． popplerのインストール方法は以下を参考にして欲しい． https://docs.ropensci.org/pdftools/ まずは，パッケージのインストールと呼び出しを実行する． install.packages(&quot;pdftools&quot;) library(pdftools) 関数pdf_text()にPDFファイルのパスを指定すれば，テキストを抽出した結果が得られる． 1ページごとの内容が文字列のベクトルになっている． # https://docs.ropensci.org/pdftools/ url &lt;- &quot;http://arxiv.org/pdf/1403.2805.pdf&quot; destfile &lt;- &quot;1403.2805.pdf&quot; curl::curl_download(url, destfile) txt &lt;- pdftools::pdf_text(destfile) tibble::as_tibble(txt) ## # A tibble: 29 × 1 ## value ## &lt;chr&gt; ## 1 &quot; The jsonlite Package: A Pract… ## 2 &quot;JSON with R. We refer to Nolan and Temple Lang (2014) for a comprehensive i… ## 3 &quot;homogenous. And indeed, some implementations will now return a list instead… ## 4 &quot;The alternative to class-based method dispatch is to use type-based encodin… ## 5 &quot;2 Converting between JSON and R classes\\n\\nThis section lists example… ## 6 &quot;encoding. However, the problem with encoding missing values as strings is t… ## 7 &quot;limitations as text based formats such as CSV.\\n\\n\\n2.1.3 Special case… ## 8 &quot;is assuming an array, the application will likely break. Any consumer or cl… ## 9 &quot;We expect this representation will be the most intuitive to interpret, also… ## 10 &quot;colnames(x) &lt;- c(\\&quot;Treatment A\\&quot;, \\&quot;Treatment B\\&quot;)\\nprint(x)\\n\\n Tre… ## # ℹ 19 more rows 文字列内の\\nは改行を示しているが，そのままでは読みにくい． \\nで改行して画面で表示するにはcat()を使う． cat(txt[1]) # [1]で1ページ目 "],["RDCOMClient.html", "Chap. 20 RDCOMClientでpdfとdocxを相互変換 20.1 準備 20.2 RDCOMClient", " Chap. 20 RDCOMClientでpdfとdocxを相互変換 RDCOMClientはWindowsに特化したパッケージのため他のOSでは利用できない． 20.1 準備 CRANには登録されておらず，ウェブページかGitHubからインストールする． install.packages()でインストールする場合は，バイナリなので比較的時間が早いがRのバージョンによってはうまくインストールできないかもしれない． install_github()の場合は，コンパイルするのに少し時間がかかる． # どちらか一方でうまくいけばOK utils::install.packages(&quot;RDCOMClient&quot;, repos = &quot;http://www.omegahat.net/R&quot;, type = &quot;win.binary&quot;) devtools::install_github(&quot;omegahat/RDCOMClient&quot;) devtools::install_github(&quot;matutosi/automater&quot;) library(tidyverse) library(RDCOMClient) library(automater) 20.2 RDCOMClient convert_docs ## function (path, format) ## { ## if (fs::path_ext(path) == format) { ## return(invisible(path)) ## } ## no &lt;- switch(format, docx = 11, pdf = 17, xps = 19, html = 20, ## rtf = 23, txt = 25) ## path &lt;- normalizePath(path) ## suppressWarnings({ ## converted &lt;- normalizePath(path_convert(path, pre = &quot;converted_&quot;, ## ext = format)) ## }) ## wordApp &lt;- RDCOMClient::COMCreate(&quot;Word.Application&quot;) ## wordApp[[&quot;Visible&quot;]] &lt;- TRUE ## wordApp[[&quot;DisplayAlerts&quot;]] &lt;- FALSE ## doc &lt;- wordApp[[&quot;Documents&quot;]]$Open(path, ConfirmConversions = FALSE) ## doc$SaveAs2(converted, FileFormat = no) ## doc$close() ## return(invisible(converted)) ## } ## &lt;bytecode: 0x0000025913db7220&gt; ## &lt;environment: namespace:automater&gt; convert_docs()の中でファイルの読み込み・保存でファイル名を指定する． その際にnormalizePath()を使う必要がある． この部分を別の関数に置き換えても大丈夫かと考えて，fs::path_norm()を使ってみたところエラーになった． このように，コードを改善しようとする場合は，作業の結果としてうまく動作しないことがよくり，注意が必要である． doc$SaveAs2()のFileFormat = noで保存形式をそれに対応する数値で指定している． このあたりは，試行錯誤の結果である． もしかしたら他の形式での保存が可能なのかもしれないが，確実に変換できるのは以下の5つである． pdf：PDF xps：XML Paper Specification(xmlベースファイル形式) html：HTML rtf：リッチテキスト txt：テキスト なお，convert_docs()の実行時には，MS Wordを起動してその機能としてファイルの読み込み・保存をする． そのため，MS Wordがインストールされていないと，この関数は使えない． 複数のdocxファイルを圧縮したzipファイルがあり，ファイル解凍，PDFへの変換，1つのPDFファイルへの結合をするようなコードは以下のとおりである． 結合時の順序はファイル名の順序に従う． そのため，PDFファイルでのファイル順を踏まえて，docxの命名規則を決める必要がある． unzip()で解凍 fs::dir_ls()でファイル名取得 convert_docs()で形式変換 qpdf_combine()で結合 "],["microsoft365r.html", "Chap. 21 Microsoft365R 21.1 Outlookで複数メール送信を一斉送信 21.2 複数のワード文書の文字列を一括置換 21.3 年月日の更新", " Chap. 21 Microsoft365R 21.1 Outlookで複数メール送信を一斉送信 複数人に全く同じメールを送る場合は，TOやCCに複数の電子メールアドレスを入力すれば良い． また，宛先を知られるのがよろしくないときは，BCCに送信先のアドレスを，TOに自分のアドレスを入れておけば問題ない． このとき，送り先の全員に全く同じ内容，同じ添付ファイルであればメールは1つ作成すれば問題ない． でも，個々の人に対して少しだけ違う内容のメールを送りたいときとか，添付ファイルを別々のものにしたいときがある． また，単純なことだが，宛先が「みなさま」よりは，「○○様」のように宛先だけでも変更したいというときもある． 何かお願いをするときには，「みなさま」よりも直接名前を書いたほうが結構効果が高い． 例えば，学会での投票のお願いなどは，MLに流すより個別メールの方が確実だ． そのようなとき，いちいちメールを作成・編集していると面倒だし，間違いのもとになる． 名前を中途半端に修正して，3箇所のうち1箇所だけ別の人の名前にしてしまっていたり，日付と曜日があっていないなどの間違いは日常茶飯事だ． このような間違いをなくすには，個別に変更する部分と全体で統一するところを分けておき，あとはパソコンを使ってうまくつなぎ合わせる． でも，このように作成したメールの本文や宛先をいちいちコピー&amp;ペーストするのは，手間がかかるし，個々にも作業のミスが入り込む余地が大きい． 21.1.1 インストールと初期設定 この操作は，最初に1回だけ実行すればOK. # インストール install.packages(&quot;Microsoft365R&quot;) # パッケージの読み込み library(tidyverse) library(Microsoft365R) # 会社など組織で契約している場合 Microsoft365R::get_business_outlook() # 個人利用の場合 # Microsoft365R::get_personal_outlook() 21.1.2 とりあえず使う まずは，試しにメールを作って送ってみる． # 会社などで組織で契約している場合 outlook &lt;- Microsoft365R::get_business_outlook() # 個人利用の場合 # outlook &lt;- Microsoft365R::get_personal_outlook() # 個別にemailを送る場合 # メール作成のみ # メールはoutlookの下書きフォルダにも保存されている em &lt;- outlook$create_email( body = &quot;Hello from R\\nHello from R\\n&quot;, subject = &quot;Hello&quot;, to = &quot;matutosi@gmail.com&quot;, cc = &quot;matutosi@konan-wu.ac.jp&quot; ) # メール送信 em$send() # outlookの下書きフォルダからメールを取り出す drafts &lt;- outlook$get_drafts()$list_emails() # 下書きフォルダのメール一覧 drafts # 下書きフォルダのメールの1つ目を送信 drafts[[1]]$send() # 受信トレイのメール一覧 inbox &lt;- outlook$get_inbox()$list_emails() # 受信トレイの1つ目の内容 inbox[[1]] 21.1.3 メールの一斉送信 宛先や本文をエクセルに入力しておき，そこからデータを抽出して一斉にメールを送信できる． 送信: send(必須) 1: 送信する，0: 下書きに保存 宛先: to(必須) CC: cc(任意) BCC: bcc(任意) 件名: subject(必須でないが，入力推奨) 本文: body(必須でないが，入力推奨) 添付ファイル: attachment(任意) 宛先が入力されていないとメールは送信できない． CCとBCCは任意． 件名と本文はなくても送信できるが，両方とも何もないとメールの意味がない． 添付ファイルがあれば，ファイル名を指定． 複数ファイルを添付するときは，カンマでpath(ファイル名)を区切る． 絶対pathで指定すると間違いは少ない． # 宛先や本文をエクセルで作成しておき # 一斉にメールを作成・送信する場合 # 関数の読み込み source(&quot;https://gist.githubusercontent.com/matutosi/bed00135698c8e3d2c49ef08d12eef9c/raw/6acc2de844eeeab03aaf36f2391e223d621b36a8/outlook.R&quot;) outlook &lt;- Microsoft365R::get_business_outlook() # エクセルファイルの内容 # working directoryにファイルがない場合は， # 絶対パス(&quot;c:/user/documents/outlook.xlsx&quot;など)で指定 path &lt;- &quot;outlook.xlsx&quot; # メール作成・送信 create_email(path, outlook, send = TRUE) # メール作成のみ # &quot;send = FALSE&quot; にすれば，メールを作成して下書きに保存 create_email(path, outlook, send = FALSE) 21.2 複数のワード文書の文字列を一括置換 多くのプログラマは，普段はそれぞれの好みのテキストエディタを使っていいるだろう． 私はWindowsでは古典的なエディタである秀丸エディタを長らく使っている． キー割り当てのカスタマイズや自分用の細かなマクロがあるので，今さらエディタを変更できない． ートパソコンではThinkPadをずっと使っているので，キーボード自体も変更できない． これを変更すると作業効率が悪くなってしまう． そのため，デスクトップパソコンでもThinkPadキーボードを愛用している． このようにエディタとキーボードだけでパソコンの作業が完了すれば良いのだが，仕事上ワードで文書を作成しなければならないことがある． ワードは余計なおせっかいをたくさんしてくれるので，不要なことはしないように設定している． それでも，できればワードでの作業は最小限にしたいのが本音である． 起動に時間はかかるし，置換で使える正規表現がちょっと変だからである． Rからワード文書内の文字列を置換すれば，ワードを起動する手間が省略できる． また，正規表現を使った置換や複数の組み合わせの置換もできる． さらに，「AをB」に「BをA」にという入れ替えも，プログラムで途中に別の文字列への置き換えで実現できる． このとき途中で使う文字列が元の文書内にないことは必須条件であるが，これもプログラムで確認可能である． もちろん，複数ファイルでの置換やファイル名を正規表現で指定することもできる． 21.2.1 置換のコードの例 # https://ardata-fr.github.io/officeverse/index.html # https://github.com/omegahat/RDCOMClient # install.packages(&quot;officer&quot;) pkg &lt;- &quot;D:/matu/work/ToDo/automater/R&quot; devtools::load_all(pkg) library(officer) library(tidyverse) wd &lt;- &quot;d:/&quot; setwd(wd) replacement &lt;- read.table(&quot;replacement.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) files &lt;- replacement[[&quot;file&quot;]] %&gt;% stringr::str_c(collapse = &quot;|&quot;) %&gt;% fs::dir_ls(regexp = .) %&gt;% exclude(stringr::str_detect(., &quot;^replaced\\\\_&quot;)) replacement &lt;- expand_file(replacement, files) files %&gt;% purrr::walk(replace_docs, replacement) 21.3 年月日の更新 毎年同じような文書を作成しているが，年だけを更新しなければならないことは多いだろう． 手作業で日付を更新すると，どうしても間違いが混入する． 単純な見間違いや入力間違いもあれば，日付を変更して曜日を変更し忘れる，あるいは日付を変更し忘れることをやってしまいがちだ． このような更新作業も，Wordの検索・置換の機能で可能だし，Rから特定の日付を別の日付に変換できる． いっそのことなら，日付を文書内で自動的に取得して日付あるいは曜日を更新できれば楽ができる． 例えば，「2023年4月10日(月)」を2024年に変更することを考えよう． 何番目の何曜日かで日付が決まっているなら，2023年4月10日は第2月曜日である． この場合は，2024年4月の第2月曜日は「2024年4月8日(月)」なので，「2023年4月10日(月)」を「2024年4月8日(月)」に置換する． 一方，日付固定なら「2024年4月10日(水)」に置換する． さらに，求めた日が日曜日の場合は前日の土曜日あるいは月曜日にずらすとか，10月1日の前後3日以内の火曜日のような法則でも可能である． 祝日との関連で日付を決定することもあるだろう． そのようなときは，祝日データをあわせてコードに入れれば良い． とにかく，決め方が明確で1つに日付を決めることができれば，プログラムによる自動化できる． ここではlubridateを活用して，ワード文書の日付を更新する方法を扱う． lubridateで日付固定あるいは位置固定のときでの翌年の年月日を求める方法は以下を参考にして欲しい． lubridateで日付・時刻を扱う 21.3.1 活用例 ワード文書内の日付は，正規表現を用いて入手できる． それぞれの曜日なし版が考えられ，月と日が1桁の時に「04」のようにパディング(桁合わせ)されていることもあるだろう． これらは，正規表現によって対応可能である． もちろん，日付っぽい表記のすべてを含むことはできないが，よく使う日付表記は網羅できるだろう． 年表記が2桁の場合，半角や全角のスペースを途中に含んだり，「()」の半角・全角の違いなどの表現揺れもあり得る． 表記揺れを修正するための置換や削除などは，stringr(あるいはbase)の関数で対応できる． # 20\\d\\d年月日 # / library(tidyverse) ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors x &lt;- &quot;21年1月1日(月)，2021年1月1日(月)，2021年10月10日(月)，2月2日(月)，12月22日(月)，2021/1/1(月)，2021/10/10(月)，2/2(月)，12/22(月)，21年1月1日，2021年1月1日，2021年10月10日，2月2日，12月22日，2021/1/1，2021/10/10，2/2，12/22&quot; regrep &lt;- &quot;((20)*[2-5]\\\\d+[年/_-]*)*\\\\d\\\\d*[月/_-]*\\\\d\\\\d*[日]*(\\\\([月火水木金土日]\\\\))*&quot; stringr::str_extract_all(x, regrep) ## [[1]] ## [1] &quot;21年1月1日(月)&quot; &quot;2021年1月1日(月)&quot; &quot;2021年10月10日(月)&quot; ## [4] &quot;2月2日(月)&quot; &quot;12月22日(月)&quot; &quot;2021/1/1(月)&quot; ## [7] &quot;2021/10/10(月)&quot; &quot;2/2(月)&quot; &quot;12/22(月)&quot; ## [10] &quot;21年1月1日&quot; &quot;2021年1月1日&quot; &quot;2021年10月10日&quot; ## [13] &quot;2月2日&quot; &quot;12月22日&quot; &quot;2021/1/1&quot; ## [16] &quot;2021/10/10&quot; &quot;2/2&quot; &quot;12/22&quot; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
