# magrittrでコードを簡潔に {#magrittr}

<!--
-->
パッケージmagrittrはちょっと変わったパッケージである．
そもそも名前が変わっていて何と読んで良いのか分からない．
公式ページには「magrittr (to be pronounced with a sophisticated french accent) 」と書かれている．
フランス語は，大学の第2外国語で習ったが，すでに記憶の彼方に沈んでしまっている．
主な関数がパイプ(`%>%`)である点も変わっている．

このように，ちょっと変わったパーッケージではあるものの，Rを使う際には欠かせないパッケージといっても過言ではない．
Rのバージョン4.1以降では，base機能のパイプとして`|>`が使えるようになったが，第1引数(`_`)とその名前を明示しないといけないなど若干使いにくい．
そこでここでは，コードを簡潔に書くためのmagrittrのパイプ(`%>%`)と関連した関数を紹介する．

## 準備

例によって，インストールとパッケージの呼び出しをしておく．


```r
install.packages("magrittr")
```


```r
library(tidyverse)
library(magrittr)
```

## magrittrとtidyverse

tidyverseは，Rでのデータ解析には欠かせないものになっている．
Rの起動時にtidyverseを読み込む人は多いだろう．
tidyverseを読み込むと，その中のパッケージ(forcats，tibble，stringr，dplyr，tidyr，purrr)がインポートした`%>%`を使うことができる．
そのため，私は`%>%`がtidyverseの独自のものだと勘違いをしていた．
`%>%`はもとはパッケージmagrittrの関数である．

ただし，tidyverseと`%>%`の相性は非常によい．
tidyverseの関数では，第1引数のオブジェクトがdplyrではデータフレーム，stringrでは文字列などのように，それぞれのパッケージで引数とするオブジェクトが統一されている．
そのため，簡潔にコードを書くことができる．
なお，パイプの手入力は手間がかかるので，ショートカットを利用する．
RStudioでは，Ctrl + Shift + Mである．
テキストエディタを使っているときはマクロやスクリプトを組んでショートカットを設定することをお勧めする．

`%>%`は，慣れるまでは何が便利なのか分からないが，慣れると欠かせなくなる．
さらに使っていると，癖なってしまって無駄にパイプを繋ぐこともある．
長過ぎるパイプは良くないのは当然であるものの，適度に使うとRでのプログラミングは非常に楽になる．

## `%>%`でコードを簡潔に

最近のRでは，パイプ(`%>%`)を多用したコードをよく目にする．
はじめてみると，面食らって思考停止に陥ってしまうかも知れない．
しかし，恐れることはない．
以下では簡単な例を使って説明する．


```r
a <- a %>% fun() # あるとき：慣れていないと変な感じ
a <- fun(a)      # ないとき：こっちのほうが分かりやすい
```

ある時とない時と比べると，ある時の方がコードが長くなっていて，何が便利なのかわからないだろう．
著者も正直なところ，少し見たときには便利さが全くわからなかった．


```r
  # ないとき：「a <- 」が何度も必要
a <- fun1(a)
a <- fun2(a)
a <- fun3(a)
  # 力技!：括弧が見づらい
a <- fun3(fun2(fun1(a)))
  # あるとき
a <- a %>%   # aに(以下の結果を)代入
  fun1() %>% # fun1を実行
  fun2() %>% # fun2を実行
  fun3() %>% # fun3を実行
```

パイプを使うと，左側のオブジェクトを右側の関数の第1引数として使うため，引数が1つだけの場合は引数を書く必要がなくなる．
このようにオブジェクトaに対して， fun1，fun2，fun3と順に関数を適用するということは，しばしば出てくる．
特に，dplyrで`select()`，`filter()`，`group_by()`，`summarise()`などを使う時はそうである．
その時，代入先のオブジェクト名を1回ずつ新たに考えるのは，非常に面倒である．
どこまでを同じ変数名として，どこで変えるかなど考えるのは手間だ．
キーボードでの打ち込みが多いほど，オブジェクト名の重複や入力間違いが発生する可能性が高くなり，バグの温床である．
これを避ける方法は入れ子状に書くことであるが，括弧の対応がよくわからず頭が混乱する．
正直なところ，著者は時々このようなコードを書くことがある．
しかし，他人から見たらこんな馬鹿げて見にくいコードは無い．

パイプを使うと，これらの問題が解決する．
また，見た目にもわかりやすくコードの再利用もしやすい利点もある．
見た目では，1つの作業が1行にあるため，可読性が高く人間の思考回路にも近い．
再利用するときに，処理対象のオブジェクトを引数として明記しなくても良いため，前後の文脈に左右されずに必要な部分のコードだけを複写・貼付できる．
慣れるには，ほんの少しの時間がかかるかもしれないが，ぜひとも活用してほしい．


## パイプの仲間

- `%<>%`   
- `%T>%`(Tパイプというらしい)   
- `%$%`    

これらの関数は，tidyverseには含まれていないため，使用するにはmagrittrを読み込む必要がある．
`%>%`と似た機能を持つ．

### `%<>%`でオブジェクトを代入

`%<>%`は，パイプを使って処理した内容を，最初のオブジェクトに再度代入するときに使う．
ほんの少しだけ，コードを短くできる．


```r
head(mpg) # 燃費データ
```

```
## # A tibble: 6 x 11
##   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class 
##   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> 
## 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa~
## 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa~
## 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa~
## 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa~
## 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa~
## 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa~
```

```r
tmp <- mpg
tmp <-
  tmp %>%
  dplyr::filter(year==1999) %>%
  tidyr::separate(trans, into=c("trans1", "trans2", NA))

tmp <- mpg
tmp %<>%
  dplyr::filter(year==1999) %>%
  tidyr::separate(trans, into=c("trans1", "trans2", NA))
```

注意点としては，試行錯誤でコードを書いている途中は，あまり使わないほうが良いだろう．
もとのオブジェクトが置き換わるので，処理結果が求めるものでないときに，もとに戻れなくなってしまうためだ．
コードを短くできるのは1行で，可読性が特に高くなるというわけでもない．
便利なことは便利で，私も一時期はよく使用していた．
しかし，上記の理由もあって，最近はほとんど使用していない．

### `%T>%`でコードを分岐

処理途中に分岐をして別の処理をさせたいときに使う．
例えば，ちょっとだけ処理して，変数に保存するときに使う．
imapと組み合わせて，保存する画像のファイル名を設定する時に使うと便利である．


`%T>%`は便利ではあるが，以下の点で注意が必要である．

- 分岐途中の結果をオブジェクトに代入するときには，`<-`ではなく，`<<-`を使う   
- 明示的に`.`を使う   
- 複数処理があれば，`{`と`}`で囲う   
- 処理終了後に`%>%`が必要   

`%T>%`を使うとコードの途中に，ちょっとだけ枝分かれしたコードを挿入できる．
有用な機能ではあるが，トリッキーなコードになる可能性があるため，使いすぎには気をつけたい．


以下の例は，あまり実用的なものではないが，簡単な例として示す．


```r
iris %>%
  tibble::tibble() %>%
  split(.$Species) %>%          # Speciesで分割
  purrr::map(print, n = 3) %T>% # それぞれ3行だけ表示
  {
    sp_path <<- paste0(names(.), ".txt") # ファイル名：種名.txt
  } %>%
  purrr::map(dplyr::select_if, is.numeric) %>% # 数値だけを選択
  purrr::map(dplyr::summarise_all, mean) %>%   # 平均を算出
  purrr::map2(.x = ., .y = sp_path, readr::write_csv) # 種ごとにcsvを保存
```

Tパイプは，Tの文字の形が意味をなしており，左から来たデータを分岐させて右側と下側に流す役割をする．
上の例では，分岐した途中でファイル名`sp_path`を生成するために，(わざと)分岐を入れている．
このコードで本来`{}`は不要だが，入れておくとTパイプを使っている部分がわかりやすい．
ファイル名を生成したあと(`}`の後ろ)には，上から流れてきたものがそのまま`purrr::map()`の第1引数として使われる．
`select_if()`と`dplyr::summarise_all()`をしてから，最終的にファイルとして出力する．
`map2()`は`map()`の引数を2つとるバージョンであり，第1引数に上から来たデータフレームを，第2引数にファイル名を使っている．

なお，最後の`map2()`を`purrr::walk2`とすると種ごとの平均値は画面には出力されず，ファイルへの出力だけになる．
さらに余談だが，上で「(わざと)」と書いたのは，Tパイプを使わずに，最後のところを`map2(.x = ., .y = paste0(names(.), ".txt"), readr::write_csv)`とすれば同じ結果が得られるためである．


```r
iris %>%
  tibble::tibble() %>%
  split(.$Species) %>%
  purrr::map(dplyr::select_if, is.numeric) %>%
  purrr::map(dplyr::summarise_all, mean) %>%
  map2(.x = ., .y = paste0(names(.), ".txt"), readr::write_csv)
```


### `%$%`で`$`のショートカット

`%$%`は，`%>%`と`.$`の組み合わせのショートカットである．


```r
mpg %>% .$manufacturer %>% head()
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

```r
mpg %$%   manufacturer %>% head()
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

パッケージ開発ではパイプを使った場合の`.`が推奨されていない．
パッケージ開発時に欠かせないチェック(R CMD check)ではpossible problemとしてWarningが出力される．
そのため，そのままではCRANでは受け付けてもらえない．
Githubでパッケージを公開するならそれでも問題はないが，Checkで毎回Warningが出力されるのは，心理的に嬉しくない．

そこで，DESCRIPTIONで次のように`%$%`をインポートしておくと，`.$`を使わなくても良い．
<!--
なお，`%>%`だけなら，usethis::use_pipe()とすれば，開発パッケージのDESCRIPTIONに，importFrom(magrittr,"%>%")を書いてくれる．
-->


```r
importFrom(magrittr,"%$%")
```

なお余談ではあるが，この場合は`$`の代わりに`[[`と`]]`を使っても同じ結果が得られる．
`[`と`]`ではデータフレームの1列をそのまま取り出すので，結果が異なる．


```r
mpg %>% .$manufacturer      %>% head()
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

```r
mpg %>% .[["manufacturer"]] %>% head()
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

```r
mpg %>% .["manufacturer"]   %>% head()
```

```
## # A tibble: 6 x 1
##   manufacturer
##   <chr>       
## 1 audi        
## 2 audi        
## 3 audi        
## 4 audi        
## 5 audi        
## 6 audi
```

`[[ ]]`と`[ ]`は，それぞれ`[[`と`[`という関数であるため，以下のように書くことができる．
この場合，第1引数がパイプの前から引き継がれるため，`.`を明示しなくてもよい．


```r
mpg %>% `$`(manufacturer)    %>% head()
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

```r
mpg %>% `[[`("manufacturer") %>% head() # mpg %>% `[[`(., "manufacturer") と同じ
```

```
## [1] "audi" "audi" "audi" "audi" "audi" "audi"
```

```r
mpg %>% `[`("manufacturer")  %>% head()
```

```
## # A tibble: 6 x 1
##   manufacturer
##   <chr>       
## 1 audi        
## 2 audi        
## 3 audi        
## 4 audi        
## 5 audi        
## 6 audi
```

## パイプ以外の関数

magrittrにはパイプとともに使うと便利な関数も含まれている．
例えば，パイプを使ったコードの中で列名を変更したいことがある．
`set_colnames()`はデータフレームの列名を変更する時に便利だ．
これを使わずに列名を変更しようとすると，ちょっとトリッキーな関数`colnames<-()`を使うか，途中でコードを区切る必要がある．


```r
hoge <- dplyr::select(mpg, 1:2)
cnames <- c("foo", "bar")
 # colnames(hoge) <- cnames      # 通常のコード
`colnames<-`(hoge, cnames)       # トリッキーなコード
hoge %>% 
  magrittr::set_colnames(cnames)
```


<!--
ところで，`dplyr::rename()`や`dplyr::select()`を使って列名を変更する方法もあるが，もとの列名も指定する必要がある．
-->


## コラム：magrittrの不思議な関数たち

magrittrは，そもそも変わったパッケージだが，不思議な名前の関数もある．


```r
add          # `+`
subtract     # `-`
multiply_by  # `*`
divide_by    # `/`
```

`?not`とすれば，似たような不思議な関数の一覧と説明が出てくる．
特に四則演算をする関数の場合は，パイプと一緒に使うと若干だが読みやすい．
`+`と同じ機能である`add`であれば，以下のようになる．


```r
1:10 %>% 
  `+`(100)
```

```
##  [1] 101 102 103 104 105 106 107 108 109 110
```

```r
1:10 %>% 
  add(100)
```

```
##  [1] 101 102 103 104 105 106 107 108 109 110
```

パイプで使わない場合は，普通の四則演算の方がわかりやすい．


```r
1:10 + 100
```

```
##  [1] 101 102 103 104 105 106 107 108 109 110
```

```r
add(1:10, 100)
```

```
##  [1] 101 102 103 104 105 106 107 108 109 110
```


論理演算で使う関数もパイプで使うと読みやすくなりそう．


```r
and          # `&`
or           # `|`
equals       # `==`
not          # `!`，`n'est pas`(フランス語)も同じ
```

`&`や`|`で，条件が多くなってくると読みにくくなるので，改行するかパイプで繋いで1つ1つの条件を短くするとコードが読みやすくなる．


```r
rep(c(TRUE, FALSE), times = 5) %>%
  and(rep(c(TRUE, FALSE), each = 5))
```

```
##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
```

```r
rep(c(TRUE, FALSE), times = 5) %>%
  or(rep(c(TRUE, FALSE), each = 5))
```

```
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE
```

